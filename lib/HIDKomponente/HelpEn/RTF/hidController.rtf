{\rtf1\ansi{\fonttbl{\f0\fswiss Courier New;}{\f1\fswiss Arial;}{\f2\fswiss Wingdings;}{\f3\fswiss MS Sans Serif;}}{\colortbl\red0\green0\blue196;\red100\green0\blue255;\red0\green0\blue255;}
\sa50\sb50\f3\fs20
#{\footnote # IDH_Class_TJvHidDevice}
${\footnote $ TJvHidDevice}
K{\footnote K TJvHidDevice}
A{\footnote A TJvHidDevice_Object;TJvHidDevice}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50
{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\f1\fs28  \cf2 TJvHidDevice Object}\line
{\fs20{\ul Hierarchy\v IDH_Anym_3FAMT_1}    {\uldb Properties\v pme_cp_TJvHidDevice>pme}   {\uldb Methods\v pme_cm_TJvHidDevice>pme}   {\uldb Events\v pme_ce_TJvHidDevice>pme}\tab{\uldb Utilities\v pme_ce_Utilities>pme}   }\par\pard}
\b Declaration\b0\par
{\f0 TJvHidDevice = \b class\b0 (TObject)}\par\pard\sa0\sb0
{#{\footnote # IDH_ClassTopic_TJvHidDevice_Properties}}
A TJvHidDevice object represents a physical HID device. All static informations of the 
device have been read into properties of the object. The object is created at runtime 
by a {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController>Main} which reigns all TJvHidDevice objects.
\par\page

#{\footnote # pme_cp_TJvHidDevice}
${\footnote $ Properties for TJvHidDevice}
+{\footnote + Auto}
\sa50\sb50
{\keepn{\f1\fs20\cf2\b{\uldb TJvHidDevice\v IDH_Class_TJvHidDevice>Main} Properties\b0}\line
{\fs20{\ul Legend\v IDH_Legend}}\par\pard}
{\f1\tx300\b In TJvHidDevice\b0\line
\{bmct readonly.bmp\}\tab{\uldb Attributes\v IDH_TJvHidDevice_Attributes>Main}\line
\{bmct readonly.bmp\}\tab{\uldb Caps\v IDH_TJvHidDevice_Caps>Main}\line
\{bmct empty.bmp\}\tab{\uldb Configuration\v IDH_TJvHidDevice_Configuration>Main}\line
\{bmct readonly.bmp\}\tab{\uldb DeviceStrings\v IDH_TJvHidDevice_DeviceStrings>Main}\line
\{bmct readonly.bmp\}\tab{\uldb DeviceStringsUnicode\v IDH_TJvHidDevice_DeviceStringsUnicode>Main}\line
\{bmct readonly.bmp\}\tab{\uldb HasReadWriteAccess\v IDH_TJvHidDevice_HasReadWriteAccess>Main}\line
\{bmct readonly.bmp\}\tab{\uldb HidFileHandle\v IDH_TJvHidDevice_HidFileHandle>Main}\line
\{bmct readonly.bmp\}\tab{\uldb HidOverlappedRead\v IDH_TJvHidDevice_HidOverlappedRead>Main}\line
\{bmct readonly.bmp\}\tab{\uldb HidOverlappedWrite\v IDH_TJvHidDevice_HidOverlappedWrite>Main}\line
\{bmct readonly.bmp\}\tab{\uldb HidOverlappedReadResult\v IDH_TJvHidDevice_HidOverlappedReadResult>Main}\line
\{bmct readonly.bmp\}\tab{\uldb HidOverlappedWriteResult\v IDH_TJvHidDevice_HidOverlappedWriteResult>Main}\line
\{bmct readonly.bmp\}\tab{\uldb IsCheckedOut\v IDH_TJvHidDevice_IsCheckedOut>Main}\line
\{bmct readonly.bmp\}\tab{\uldb IsPluggedIn\v IDH_TJvHidDevice_IsPluggedIn>Main}\line
\{bmct readonly.bmp\}\tab{\uldb LanguageStrings\v IDH_TJvHidDevice_LanguageStrings>Main}\line
\{bmct readonly.bmp\}\tab{\uldb LinkCollectionNodes\v IDH_TJvHidDevice_LinkCollectionNodes>Main}\line
\{bmct empty.bmp\}\tab{\uldb LinkCollectionParam\v IDH_TJvHidDevice_LinkCollectionParam>Main}\line
\{bmct readonly.bmp\}\tab{\uldb MaxButtonListLength\v IDH_TJvHidDevice_MaxButtonListLength>Main}\line
\{bmct readonly.bmp\}\tab{\uldb MaxDataListLength\v IDH_TJvHidDevice_MaxDataListLength>Main}\line
\{bmct readonly.bmp\}\tab{\uldb MaxUsageListLength\v IDH_TJvHidDevice_MaxUsageListLength>Main}\line
\{bmct empty.bmp\}\tab{\uldb NumInputBuffers\v IDH_TJvHidDevice_NumInputBuffers>Main}\line
\{bmct empty.bmp\}\tab{\uldb NumOverlappedBuffers\v IDH_TJvHidDevice_NumOverlappedBuffers>Main}\line
\{bmct readonly.bmp\}\tab{\uldb PhysicalDescriptor\v IDH_TJvHidDevice_PhysicalDescriptor>Main}\line
\{bmct readonly.bmp\}\tab{\uldb PnPInfo\v IDH_TJvHidDevice_PnPInfo>Main}\line
\{bmct readonly.bmp\}\tab{\uldb PreparsedData\v IDH_TJvHidDevice_PreparsedData>Main}\line
\{bmct readonly.bmp\}\tab{\uldb ProductName\v IDH_TJvHidDevice_ProductName>Main}\line
\{bmct empty.bmp\}\tab{\uldb ReportTypeParam\v IDH_TJvHidDevice_ReportTypeParam>Main}\line
\{bmct readonly.bmp\}\tab{\uldb SerialNumber\v IDH_TJvHidDevice_SerialNumber>Main}\line
\{bmct empty.bmp\}\tab{\uldb Tag\v IDH_TJvHidDevice_Tag>Main}\line
\{bmct empty.bmp\}\tab{\uldb ThreadSleepTime\v IDH_TJvHidDevice_ThreadSleepTime>Main}\line
\{bmct empty.bmp\}\tab{\uldb UsagePageParam\v IDH_TJvHidDevice_UsagePageParam>Main}\line
\{bmct empty.bmp\}\tab{\uldb UsageParam\v IDH_TJvHidDevice_UsageParam>Main}\line
\{bmct readonly.bmp\}\tab{\uldb VendorName\v IDH_TJvHidDevice_VendorName>Main}
}\par\page

#{\footnote # pme_cm_TJvHidDevice}
${\footnote $ Methods for TJvHidDevice}
+{\footnote + Auto}
\sa50\sb50{\keepn{\f1\fs20\cf2\b{\uldb TJvHidDevice\v IDH_Class_TJvHidDevice>Main} Methods\b0}\line
{\fs20{\ul Legend\v IDH_Legend}}\par\pard}
{\f1\tx300\b In TJvHidDevice\b0\line
\{bmct empty.bmp\}\tab{\uldb CancelIO\v IDH_TJvHidDevice_CancelIO>Main}\line
\{bmct empty.bmp\}\tab{\uldb CheckOut\v IDH_TJvHidDevice_CheckOut>Main}\line
\{bmct empty.bmp\}\tab{\uldb CloseFile\v IDH_TJvHidDevice_CloseFile>Main}\line
\{bmct empty.bmp\}\tab{\uldb CloseFileEx\v IDH_TJvHidDevice_CloseFileEx>Main}\line
\{bmct empty.bmp\}\tab{\uldb Create\v IDH_TJvHidDevice_Create>Main}\line
\{bmct empty.bmp\}\tab{\uldb DeviceIoControl\v IDH_TJvHidDevice_DeviceIoControl>Main}\line
\{bmct empty.bmp\}\tab{\uldb Destroy\v IDH_TJvHidDevice_Destroy>Main}\line
\{bmct empty.bmp\}\tab{\uldb FlushQueue\v IDH_TJvHidDevice_FlushQueue>Main}\line
\{bmct empty.bmp\}\tab{\uldb GetButtonCaps\v IDH_TJvHidDevice_GetButtonCaps>Main}\line
\{bmct empty.bmp\}\tab{\uldb GetButtons\v IDH_TJvHidDevice_GetButtons>Main}\line
\{bmct empty.bmp\}\tab{\uldb GetButtonsEx\v IDH_TJvHidDevice_GetButtonsEx>Main}\line
\{bmct empty.bmp\}\tab{\uldb GetData\v IDH_TJvHidDevice_GetData>Main}\line
\{bmct empty.bmp\}\tab{\uldb GetExtendedAttributes\v IDH_TJvHidDevice_GetExtendedAttributes>Main}\line
\{bmct empty.bmp\}\tab{\uldb GetFeature\v IDH_TJvHidDevice_GetFeature>Main}\line
\{bmct empty.bmp\}\tab{\uldb GetInputReport\v IDH_TJvHidDevice_GetInputReport>Main}\line
\{bmct empty.bmp\}\tab{\uldb GetScaledUsageValue\v IDH_TJvHidDevice_GetScaledUsageValue>Main}\line
\{bmct empty.bmp\}\tab{\uldb GetSpecificButtonCaps\v IDH_TJvHidDevice_GetSpecificButtonCaps>Main}\line
\{bmct empty.bmp\}\tab{\uldb GetSpecificValueCaps\v IDH_TJvHidDevice_GetSpecificValueCaps>Main}\line
\{bmct empty.bmp\}\tab{\uldb GetUsages\v IDH_TJvHidDevice_GetUsages>Main}\line
\{bmct empty.bmp\}\tab{\uldb GetUsagesEx\v IDH_TJvHidDevice_GetUsagesEx>Main}\line
\{bmct empty.bmp\}\tab{\uldb GetUsageValue\v IDH_TJvHidDevice_GetUsageValue>Main}\line
\{bmct empty.bmp\}\tab{\uldb GetUsageValueArray\v IDH_TJvHidDevice_GetUsageValueArray>Main}\line
\{bmct empty.bmp\}\tab{\uldb GetValueCaps\v IDH_TJvHidDevice_GetValueCaps>Main}\line
\{bmct empty.bmp\}\tab{\uldb InitializeReportForID\v IDH_TJvHidDevice_InitializeReportForID>Main}\line
\{bmct empty.bmp\}\tab{\uldb OpenFile\v IDH_TJvHidDevice_OpenFile>Main}\line
\{bmct empty.bmp\}\tab{\uldb OpenFileEx\v IDH_TJvHidDevice_OpenFileEx>Main}\line
\{bmct empty.bmp\}\tab{\uldb ReadFile\v IDH_TJvHidDevice_ReadFile>Main}\line
\{bmct empty.bmp\}\tab{\uldb ReadFileEx\v IDH_TJvHidDevice_ReadFileEx>Main}\line
\{bmct empty.bmp\}\tab{\uldb SetButtons\v IDH_TJvHidDevice_SetButtons>Main}\line
\{bmct empty.bmp\}\tab{\uldb SetData\v IDH_TJvHidDevice_SetData>Main}\line
\{bmct empty.bmp\}\tab{\uldb SetFeature\v IDH_TJvHidDevice_SetFeature>Main}\line
\{bmct empty.bmp\}\tab{\uldb SetOutputReport\v IDH_TJvHidDevice_SetOutputReport>Main}\line
\{bmct empty.bmp\}\tab{\uldb SetScaledUsageValue\v IDH_TJvHidDevice_SetScaledUsageValue>Main}\line
\{bmct empty.bmp\}\tab{\uldb SetUsages\v IDH_TJvHidDevice_SetUsages>Main}\line
\{bmct empty.bmp\}\tab{\uldb SetUsageValue\v IDH_TJvHidDevice_SetUsageValue>Main}\line
\{bmct empty.bmp\}\tab{\uldb SetUsageValueArray\v IDH_TJvHidDevice_SetUsageValueArray>Main}\line
\{bmct empty.bmp\}\tab{\uldb UnsetButtons\v IDH_TJvHidDevice_UnsetButtons>Main}\line
\{bmct empty.bmp\}\tab{\uldb UnsetUsages\v IDH_TJvHidDevice_UnsetUsages>Main}\line
\{bmct empty.bmp\}\tab{\uldb WriteFile\v IDH_TJvHidDevice_WriteFile>Main}\line
\{bmct empty.bmp\}\tab{\uldb WriteFileEx\v IDH_TJvHidDevice_WriteFileEx>Main}
}\par\page

#{\footnote # pme_ce_TJvHidDevice}
${\footnote $ Events for TJvHidDevice}
+{\footnote + Auto}
\sa50\sb50{\keepn{\f1\fs20\cf2\b{\uldb TJvHidDevice\v IDH_Class_TJvHidDevice>Main} Events\b0}\line
{\fs20{\ul Legend\v IDH_Legend}}\par\pard}
{\f1\tx300\b In TJvHidDevice\b0\line
\{bmct empty.bmp\}\tab{\uldb OnData\v IDH_TJvHidDevice_OnData>Main}\line
\{bmct empty.bmp\}\tab{\uldb OnDataError\v IDH_TJvHidDevice_OnDataError>Main}\line
\{bmct empty.bmp\}\tab{\uldb OnUnplug\v IDH_TJvHidDevice_OnUnplug>Main}
}\par\page

#{\footnote # IDH_TJvHidDevice_Attributes}
${\footnote $ TJvHidDevice.Attributes}
K{\footnote K TJvHidDevice,Attributes;Attributes,TJvHidDevice;Attributes}
A{\footnote A TJvHidDevice_Attributes;Attributes_Property;Attributes}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.Attributes\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} Attributes: THIDDAttributes;}\par
{\f0 THIDDAttributes = {\b record}\line
  Size:          ULONG;\line
  VendorID:      Word;\line
  ProductID:     Word;\line
  VersionNumber: Word;\line
{\b end};\par}
The global unique Vendor ID, Product ID and Version of the device. 
The values come directly from the device. Size is of no importance. 
The record is read in with HidD_GetAttributes.
\par\page

#{\footnote # IDH_TJvHidDevice_Caps}
${\footnote $ TJvHidDevice.Caps}
K{\footnote K TJvHidDevice,Caps;Caps,TJvHidDevice;Caps}
A{\footnote A TJvHidDevice_Caps;Caps_Property;Caps}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.Caps\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} Caps: THIDPCaps;}\par
{\f0 THIDPCaps = {\b record}\line
  Usage:                     TUsage;\line
  UsagePage:                 TUsage;\line
  InputReportByteLength:     Word;\line
  OutputReportByteLength:    Word;\line
  FeatureReportByteLength:   Word;\line
  Reserved:                  array [0..16] of Word;\line\line
  NumberLinkCollectionNodes: Word;\line\line
  NumberInputButtonCaps:     Word;\line
  NumberInputValueCaps:      Word;\line
  NumberInputDataIndices:    Word;\line\line
  NumberOutputButtonCaps:    Word;\line
  NumberOutputValueCaps:     Word;\line
  NumberOutputDataIndices:   Word;\line
  NumberFeatureButtonCaps:   Word;\line
  NumberFeatureValueCaps:    Word;\line
  NumberFeatureDataIndices:  Word;\line
{\b end};\par}
The capabilities of the device. Various sizes and counts of the device. 
The record is read in with HidP_GetCaps.
\par\page

#{\footnote # IDH_TJvHidDevice_Configuration}
${\footnote $ TJvHidDevice.Configuration}
K{\footnote K TJvHidDevice,Configuration;Configuration,TJvHidDevice;Configuration}
A{\footnote A TJvHidDevice_Configuration;Configuration_Property;Configuration}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.Configuration\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} Configuration: THIDDConfiguration;}\par
{\f0 THIDDConfiguration = {\b record}\line
  cookie:         Pointer;\line
  size:           ULONG;\line
  RingBufferSize: ULONG;\line
{\b end};\par}
This seems to describe the buffer size the driver allocates to receive packets from the device. 
Tests with a mouse and a keyboard showed that {\f0 cookie} is set on read. {\f0 size} seems untouched. 
A write failed.  
The record is read in with HidD_GetConfiguration and written with HidD_SetConfiguration. 
This property is not read in the constructor. It is marked for internal use in the 
current Microsoft documentation and can crash your program when called for some 
devices on Windows XP.
\par\page

#{\footnote # IDH_TJvHidDevice_DeviceStrings}
${\footnote $ TJvHidDevice.DeviceStrings}
K{\footnote K TJvHidDevice,DeviceStrings;DeviceStrings,TJvHidDevice;DeviceStrings}
A{\footnote A TJvHidDevice_DeviceStrings;DeviceStrings_Property;DeviceStrings}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.DeviceStrings\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} DeviceStrings[Idx: Byte]: {\b string};}\par
The string array of all the strings from the firmware of the device. 
{\uldb VendorName\v IDH_TJvHidDevice_VendorName>Main}, {\uldb ProductName\v IDH_TJvHidDevice_ProductName>Main} 
and {\uldb SerialNumber\v IDH_TJvHidDevice_SerialNumber>Main} are in this array if set.\line
There may be empty strings in the array if the device does not return a string for a specific index. 
Index 0 will always return ''. The strings have been converted from Unicode to ANSI.
\par\page

#{\footnote # IDH_TJvHidDevice_DeviceStringsUnicode}
${\footnote $ TJvHidDevice.DeviceStringsUnicode}
K{\footnote K TJvHidDevice,DeviceStringsUnicode;DeviceStringsUnicode,TJvHidDevice;DeviceStringsUnicode}
A{\footnote A TJvHidDevice_DeviceStringsUnicode;DeviceStringsUnicode_Property;DeviceStringsUnicode}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.DeviceStringsUnicode\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} DeviceStringsUnicode[Idx: Byte]: WideString;}\par
The string array of all the strings from the firmware of the device. 
{\uldb VendorName\v IDH_TJvHidDevice_VendorName>Main}, {\uldb ProductName\v IDH_TJvHidDevice_ProductName>Main} 
and {\uldb SerialNumber\v IDH_TJvHidDevice_SerialNumber>Main} are in this array if set.\line
There may be empty strings in the array if the device does not return a string for a specific index. 
Index 0 will always return ''.
This is just the same as {\uldb DeviceStrings\v IDH_TJvHidDevice_DeviceStrings>Main}, but 
the strings are in unconverted Unicode.
\par\page

#{\footnote # IDH_TJvHidDevice_HasReadWriteAccess}
${\footnote $ TJvHidDevice.HasReadWriteAccess}
K{\footnote K TJvHidDevice,HasReadWriteAccess;HasReadWriteAccess,TJvHidDevice;HasReadWriteAccess}
A{\footnote A TJvHidDevice_HasReadWriteAccess;HasReadWriteAccess_Property;HasReadWriteAccess}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.HasReadWriteAccess\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} HasReadWriteAccess: Boolean;}\par
The property tells if the device can be opened for read and write access. 
Some devices like mice and keyboards are already opened exclusively by the system.
\par\page

#{\footnote # IDH_TJvHidDevice_HidFileHandle}
${\footnote $ TJvHidDevice.HidFileHandle}
K{\footnote K TJvHidDevice,HidFileHandle;HidFileHandle,TJvHidDevice;HidFileHandle}
A{\footnote A TJvHidDevice_HidFileHandle;HidFileHandle_Property;HidFileHandle}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.HidFileHandle\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} HidFileHandle: THandle;}\par
The file handle of the device opened with\line
CreateFile({\uldb PnPInfo.DevicePath\v IDH_TJvHidDevice_PnPInfo>Main}, GENERIC_READ {\b or} GENERIC_WRITE,\line
  FILE_SHARE_READ {\b or} FILE_SHARE_WRITE, {\b nil}, OPEN_EXISTING, 0, 0);\line
The file is opened by the methods if needed. It stays open until explicitly closed with {\uldb CloseFile\v IDH_TJvHidDevice_CloseFile>Main} or 
the device is checked back in. You can open the file with the method {\uldb OpenFile\v IDH_TJvHidDevice_OpenFile>Main}.
\par\page

#{\footnote # IDH_TJvHidDevice_HidOverlappedRead}
${\footnote $ TJvHidDevice.HidOverlappedRead}
K{\footnote K TJvHidDevice,HidOverlappedRead;HidOverlappedRead,TJvHidDevice;HidOverlappedRead}
A{\footnote A TJvHidDevice_HidOverlappedRead;HidOverlappedRead_Property;HidOverlappedRead}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.HidOverlappedRead\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} HidOverlappedRead: THandle;}\par
The file handle of the device opened with\line
CreateFile({\uldb PnPInfo.DevicePath\v IDH_TJvHidDevice_PnPInfo>Main}, GENERIC_READ,\line
  FILE_SHARE_READ {\b or} FILE_SHARE_WRITE, {\b nil}, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, 0);\line
The file is opened by the methods if needed. It stays open until explicitly closed with {\uldb CloseFileEx(omhRead)\v IDH_TJvHidDevice_CloseFileEx>Main} or when 
the device is checked back in. You can open the file with the method {\uldb OpenFileEx(omhRead)\v IDH_TJvHidDevice_OpenFileEx>Main}. 
Only the method {\uldb ReadFileEx\v IDH_TJvHidDevice_ReadFileEx>Main} needs this file handle.\line
The file handle for overlapped read and write has been separated in two handles to allow easy 
read and write in separate threads. See {\uldb HidOverlappedWrite\v IDH_TJvHidDevice_HidOverlappedWrite>Main} 
for the other handle.
\par\page

#{\footnote # IDH_TJvHidDevice_HidOverlappedWrite}
${\footnote $ TJvHidDevice.HidOverlappedWrite}
K{\footnote K TJvHidDevice,HidOverlappedWrite;HidOverlappedWrite,TJvHidDevice;HidOverlappedWrite}
A{\footnote A TJvHidDevice_HidOverlappedWrite;HidOverlappedWrite_Property;HidOverlappedWrite}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.HidOverlappedWrite\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} HidOverlappedWrite: THandle;}\par
The file handle of the device opened with\line
CreateFile({\uldb PnPInfo.DevicePath\v IDH_TJvHidDevice_PnPInfo>Main}, GENERIC_WRITE,\line
  FILE_SHARE_READ {\b or} FILE_SHARE_WRITE, {\b nil}, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, 0);\line
The file is opened by the methods if needed. It stays open until explicitly closed with {\uldb CloseFileEx(omhWrite)\v IDH_TJvHidDevice_CloseFileEx>Main} or 
the device is checked back in. You can open the file with the method {\uldb OpenFileEx(omhWrite)\v IDH_TJvHidDevice_OpenFileEx>Main}. 
Only the method {\uldb WriteFileEx\v IDH_TJvHidDevice_WriteFileEx>Main} needs this file handle.
The file handle for overlapped read and write has been separated in two handles to allow easy 
read and write in separate threads. See {\uldb HidOverlappedRead\v IDH_TJvHidDevice_HidOverlappedRead>Main} 
for the other handle.
\par\page

#{\footnote # IDH_TJvHidDevice_HidOverlappedReadResult}
${\footnote $ TJvHidDevice.HidOverlappedReadResult}
K{\footnote K TJvHidDevice,HidOverlappedReadResult;HidOverlappedReadResult,TJvHidDevice;HidOverlappedReadResult}
A{\footnote A TJvHidDevice_HidOverlappedReadResult;HidOverlappedReadResult_Property;HidOverlappedReadResult}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.HidOverlappedReadResult\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} HidOverlappedReadResult: DWORD;}\par
The result of a {\uldb ReadFileEx\v IDH_TJvHidDevice_ReadFileEx>Main} call. 
The value stays 0 until the read operation completed successfully. See the ReadWriteDemo for correct usage.\line
The file handle for overlapped read and write has been separated in two handles to allow easy 
read and write in separate threads. See {\uldb HidOverlappedWriteResult\v IDH_TJvHidDevice_HidOverlappedWriteResult>Main} 
for the other result.
\par\page

#{\footnote # IDH_TJvHidDevice_HidOverlappedWriteResult}
${\footnote $ TJvHidDevice.HidOverlappedWriteResult}
K{\footnote K TJvHidDevice,HidOverlappedWriteResult;HidOverlappedWriteResult,TJvHidDevice;HidOverlappedWriteResult}
A{\footnote A TJvHidDevice_HidOverlappedWriteResult;HidOverlappedWriteResult_Property;HidOverlappedWriteResult}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.HidOverlappedWriteResult\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} HidOverlappedWriteResult: DWORD;}\par
The result of a {\uldb WriteFileEx\v IDH_TJvHidDevice_WriteFileEx>Main} call. 
The value stays 0 until the write operation completed successfully. See the ReadWriteDemo for correct usage.\line
The file handle for overlapped read and write has been separated in two handles to allow easy 
read and write in separate threads. See {\uldb HidOverlappedReadResult\v IDH_TJvHidDevice_HidOverlappedReadResult>Main} 
for the other result.
\par\page

#{\footnote # IDH_TJvHidDevice_IsCheckedOut}
${\footnote $ TJvHidDevice.IsCheckedOut}
K{\footnote K TJvHidDevice,IsCheckedOut;IsCheckedOut,TJvHidDevice;IsCheckedOut}
A{\footnote A TJvHidDevice_IsCheckedOut;IsCheckedOut_Property;IsCheckedOut}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.IsCheckedOut\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} IsCheckedOut: Boolean;}\par
A simple flag which tells you that the device has been checked out with one of the CheckOut-methods.
\par\page

#{\footnote # IDH_TJvHidDevice_IsPluggedIn}
${\footnote $ TJvHidDevice.IsPluggedIn}
K{\footnote K TJvHidDevice,IsPluggedIn;IsPluggedIn,TJvHidDevice;IsPluggedIn}
A{\footnote A TJvHidDevice_IsPluggedIn;IsPluggedIn_Property;IsPluggedIn}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.IsPluggedIn\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} IsPluggedIn: Boolean;}\par
The flag tells if the device of this object has been unplugged. All methods and all writes to properties 
will cease to work if this flag is False. Destruction of the {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController>Main} also pulls the plug.
\par\page

#{\footnote # IDH_TJvHidDevice_LanguageStrings}
${\footnote $ TJvHidDevice.LanguageStrings}
K{\footnote K TJvHidDevice,LanguageStrings;LanguageStrings,TJvHidDevice;LanguageStrings}
A{\footnote A TJvHidDevice_LanguageStrings;LanguageStrings_Property;LanguageStrings}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.LanguageStrings\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} LanguageStrings: TStringList;}\par
The list of all languages that are supported in the string descriptors of the device. 
The entries of the list are localized language names from Windows. The list may be empty.\line
Which of the languages Windows uses for {\uldb DeviceStrings\v IDH_TJvHidDevice_DeviceStrings>Main} is not 
documented. There is no way to specify the desired language with HID functions. This list can 
only tell you how good the device developer has implemented languages.\par
It seems that only Windows XP tries to access any other language than "English (US)".
\par\page

#{\footnote # IDH_TJvHidDevice_LinkCollectionNodes}
${\footnote $ TJvHidDevice.LinkCollectionNodes}
K{\footnote K TJvHidDevice,LinkCollectionNodes;LinkCollectionNodes,TJvHidDevice;LinkCollectionNodes}
A{\footnote A TJvHidDevice_LinkCollectionNodes;LinkCollectionNodes_Property;LinkCollectionNodes}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.LinkCollectionNodes\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} LinkCollectionNodes[Idx: WORD]: THIDPLinkCollectionNode;}\par
The array of all the link collection nodes of the device.\par
{\f0 THIDPLinkCollectionNode = {\b record}\line
  LinkUsage:        TUsage;\line
  LinkUsagePage:    TUsage;\line
  Parent:           Word;\line
  NumberOfChildren: Word;\line
  NextSibling:      Word;\line
  FirstChild:       Word;\line
  CollectionType:   BYTE;\line
  IsAlias:          BYTE;\line
  Reserved:         Word;\line
  UserContext:      Pointer;\line
{\b end};\par}
The elements Parent, NextSibling and FirstChild span the tree of the nodes in the usual way.\line
Zero signals no link. {\b Be warned!} This is not always true!
\par\page

#{\footnote # IDH_TJvHidDevice_LinkCollectionParam}
${\footnote $ TJvHidDevice.LinkCollectionParam}
K{\footnote K TJvHidDevice,LinkCollectionParam;LinkCollectionParam,TJvHidDevice;LinkCollectionParam}
A{\footnote A TJvHidDevice_LinkCollectionParam;LinkCollectionParam_Property;LinkCollectionParam}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.LinkCollectionParam\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} LinkCollectionParam: WORD;}\par
Many methods share common parameters. All properties with suffix Param are used as 
parameters in the implementation of the methods. So addressing the same link collection 
with more than one method reduces code by first setting LinkCollectionParam and then calling the methods. 
The Max*ListLength properties are interconnected to the Param properties. Setting the Param properties 
results in an update of the Max*ListLength properties to the correct value.
\par\page

#{\footnote # IDH_TJvHidDevice_MaxButtonListLength}
${\footnote $ TJvHidDevice.MaxButtonListLength}
K{\footnote K TJvHidDevice,MaxButtonListLength;MaxButtonListLength,TJvHidDevice;MaxButtonListLength}
A{\footnote A TJvHidDevice_MaxButtonListLength;MaxButtonListLength_Property;MaxButtonListLength}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.MaxButtonListLength\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} MaxButtonListLength: ULONG;}\par
The maximum number of elements {\uldb GetButtonCaps\v IDH_TJvHidDevice_GetButtonCaps>Main} can return. 
Use this value to allocate the correct amount of memory.
\par\page

#{\footnote # IDH_TJvHidDevice_MaxDataListLength}
${\footnote $ TJvHidDevice.MaxDataListLength}
K{\footnote K TJvHidDevice,MaxDataListLength;MaxDataListLength,TJvHidDevice;MaxDataListLength}
A{\footnote A TJvHidDevice_MaxDataListLength;MaxDataListLength_Property;MaxDataListLength}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.MaxDataListLength\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} MaxDataListLength: ULONG;}\par
The maximum number of elements {\uldb GetData\v IDH_TJvHidDevice_GetData>Main} can return. 
Use this value to allocate the correct amount of memory.
\par\page

#{\footnote # IDH_TJvHidDevice_MaxUsageListLength}
${\footnote $ TJvHidDevice.MaxUsageListLength}
K{\footnote K TJvHidDevice,MaxUsageListLength;MaxUsageListLength,TJvHidDevice;MaxUsageListLength}
A{\footnote A TJvHidDevice_MaxUsageListLength;MaxUsageListLength_Property;MaxUsageListLength}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.MaxUsageListLength\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} MaxUsageListLength: ULONG;}\par
The maximum number of elements {\uldb GetUsages\v IDH_TJvHidDevice_GetUsages>Main} 
or {\uldb GetUsagesEx\v IDH_TJvHidDevice_GetUsagesEx>Main} can return. 
Use this value to allocate the right amount of memory.
\par\page

#{\footnote # IDH_TJvHidDevice_NumInputBuffers}
${\footnote $ TJvHidDevice.NumInputBuffers}
K{\footnote K TJvHidDevice,NumInputBuffers;NumInputBuffers,TJvHidDevice;NumInputBuffers}
A{\footnote A TJvHidDevice_NumInputBuffers;NumInputBuffers_Property;NumInputBuffers}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.NumInputBuffers\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} NumInputBuffers: Integer;}\par
Tells the number of buffers for reports {\uldb HidFileHandle\v IDH_TJvHidDevice_HidFileHandle>Main} uses. 
Assign a value to change the number of buffers. The property is read with HidD_GetNumInputBuffers 
and written with HidD_SetNumInputBuffers. Setting the value works only from Windows 98 SE on.\par
You can set rather large values like 128 or above. You will lose less reports when reading.
\par\page

#{\footnote # IDH_TJvHidDevice_NumOverlappedBuffers}
${\footnote $ TJvHidDevice.NumOverlappedBuffers}
K{\footnote K TJvHidDevice,NumOverlappedBuffers;NumOverlappedBuffers,TJvHidDevice;NumOverlappedBuffers}
A{\footnote A TJvHidDevice_NumOverlappedBuffers;NumOverlappedBuffers_Property;NumOverlappedBuffers}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.NumOverlappedBuffers\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} NumOverlappedBuffers: Integer;}\par
Tells the number of buffers for reports {\uldb HidOverlappedRead\v IDH_TJvHidDevice_HidOverlappedRead>Main} uses internally. 
Assign a value to change the number of buffers. The property is read with HidD_GetNumInputBuffers and written with HidD_SetNumInputBuffers. Setting the value works only from Windows 98 SE on.\par
You can set rather large values like 128 or above. You will lose less reports when reading.
\par\page

#{\footnote # IDH_TJvHidDevice_PhysicalDescriptor}
${\footnote $ TJvHidDevice.PhysicalDescriptor}
K{\footnote K TJvHidDevice,PhysicalDescriptor;PhysicalDescriptor,TJvHidDevice;PhysicalDescriptor}
A{\footnote A TJvHidDevice_PhysicalDescriptor;PhysicalDescriptor_Property;PhysicalDescriptor}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.PhysicalDescriptor\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} PhysicalDescriptor: {\uldb TJvPhysicalDescriptor\v IDH_Type_TJvPhysicalDescriptor};}\par
The physical descriptor of the device coming directly from the firmware of the device. 
The physical descriptor may be empty, because it is optional. It describes the body parts 
the buttons and usages are controlled with.
\par\page

#{\footnote # IDH_Type_TJvPhysicalDescriptor}
${\footnote $ TJvPhysicalDescriptor}
K{\footnote K TJvPhysicalDescriptor}
A{\footnote A TJvPhysicalDescriptor_Type;TJvPhysicalDescriptor}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvPhysicalDescriptor\b0}   \line
{\fs20    {\uldb PnPInfo\v IDH_TJvHidDevice_PhysicalDescriptor}   }\par\pard}
\b Declaration\b0\par
{\f0 TJvPhysicalDescriptor = {\b array of} WORD\par}
The PhysicalDescriptor ist stored in a dynamic array. If the physical descriptor is empty then 
the Length of PhysicalDescriptor is set to 1 and the WORD contained therein has the value 0.
\par\page

#{\footnote # IDH_Type_TJvHidPnPInfo}
${\footnote $ TJvHidPnPInfo}
K{\footnote K TJvHidPnPInfo}
A{\footnote A TJvHidPnPInfo_Type;TJvHidPnPInfo}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidPnPInfo\b0}   \line
{\fs20    {\uldb PnPInfo\v IDH_TJvHidDevice_PnPInfo}   }\par\pard}
\b Declaration\b0\par
{\f0 TJvHidPnPInfo = {\b class}(TObject)\line
    // {\i private parts removed}\line
    {\b property} DeviceID:        DWORD;\line
    {\b property} DevicePath:      {\b string};\line
    // {\i registry values}\line
    {\b property} Capabilities:    DWORD;\line
    {\b property} ClassDescr:      {\b string};\line
    {\b property} ClassGUID:       {\b string};\line
    {\b property} CompatibleIDs:   TStringList;\line
    {\b property} ConfigFlags:     DWORD;\line
    {\b property} DeviceDescr:     {\b string};\line
    {\b property} Driver:          {\b string};\line
    {\b property} FriendlyName:    {\b string};\line
    {\b property} HardwareID:      TStringList;\line
    {\b property} LowerFilters:    TStringList;\line
    {\b property} Mfg:             {\b string};\line
    {\b property} UpperFilters:    TStringList;\line
    {\b property} Address:         {\b string};\line
    {\b property} BusNumber:       DWORD;\line
    {\b property} BusType:         {\b string};\line
    {\b property} Characteristics: {\b string};\line
    {\b property} DevType:         {\b string};\line
    {\b property} EnumeratorName:  {\b string};\line
    {\b property} Exclusive:       DWORD;\line
    {\b property} LegacyBusType:   {\b string};\line
    {\b property} LocationInfo:    {\b string};\line
    {\b property} PhysDevObjName:  {\b string};\line
    {\b property} Security:        {\b string};\line
    {\b property} Service:         {\b string};\line
    {\b property} UINumber:        DWORD;\line
    {\b property} UINumberFormat:  {\b string};\line
{\b end};\par}

{\f0 DeviceID} is an unique internal number assigned to each device by Windows. 
Even two otherwise identical HID devices have a different DeviceID.\par
{\f0 DevicePath} is the path name which is used to open the {\uldb HidFileHandle\v IDH_TJvHidDevice_HidFileHandle>Main} 
of the device. This is a special path which starts with \'27\\\\.\\\'27 and names the driver of the device.\par
{\f0 ClassDescr} is the user friendly name of the HID class the device is in. 
{\uldb cHidKeyboardClass\v IDH_TJvHidDeviceController_CheckOutByClass>Main}, 
{\uldb cHidMouseClass\v IDH_TJvHidDeviceController_CheckOutByClass>Main} and 
{\uldb cHidNoClass\v IDH_TJvHidDeviceController_CheckOutByClass>Main} name three of the possible classes.\par
{\f0 ClassGUID} is the GUID of the Windows class driver assigned to the device.\par
{\f0 DeviceDescr} is the user friendly description of the HID device.
This description comes from the INF file which installed the driver or is synthesized by Windows as 
a localized string.\par
{\f0 Mfg} is a user friendly text describing the device. It set on installation from the INF file.\par
Some of the elements do not apply for HID devices and are therfore always empty.\par
The record has been changed to a class to allow easier internal handling. It still has to be used as a readonly record.
\par\page

#{\footnote # IDH_TJvHidDevice_PnPInfo}
${\footnote $ TJvHidDevice.PnPInfo}
K{\footnote K TJvHidDevice,PnPInfo;PnPInfo,TJvHidDevice;PnPInfo}
A{\footnote A TJvHidDevice_PnPInfo;PnPInfo_Property;PnPInfo}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.PnPInfo\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} PnPInfo: {\uldb TJvHidPnPInfo\v IDH_Type_TJvHidPnPInfo>Main};}\par
The PnPInfo record contains all information about the device which 
is collected by the enumeration process. It is mainly information 
collected from the registry.
\par\page

#{\footnote # IDH_TJvHidDevice_PreparsedData}
${\footnote $ TJvHidDevice.PreparsedData}
K{\footnote K TJvHidDevice,PreparsedData;PreparsedData,TJvHidDevice;PreparsedData}
A{\footnote A TJvHidDevice_PreparsedData;PreparsedData_Property;PreparsedData}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.PreparsedData\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} PreparsedData: PHIDPPreparsedData;}\par
PreparsedData is an opaque data structure which is needed in the implementation of most 
methods. It is exposed as property to allow to call the HID functions directly.
\par\page

#{\footnote # IDH_TJvHidDevice_ProductName}
${\footnote $ TJvHidDevice.ProductName}
K{\footnote K TJvHidDevice,ProductName;ProductName,TJvHidDevice;ProductName}
A{\footnote A TJvHidDevice_ProductName;ProductName_Property;ProductName}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.ProductName\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} ProductName: WideString;}\par
The product name of the device coming directly from the firmware of the device. 
It may be an empty string since it is optional. 
The string is in its original Unicode form.
\par\page

#{\footnote # IDH_TJvHidDevice_ReportTypeParam}
${\footnote $ TJvHidDevice.ReportTypeParam}
K{\footnote K TJvHidDevice,ReportTypeParam;ReportTypeParam,TJvHidDevice;ReportTypeParam}
A{\footnote A TJvHidDevice_ReportTypeParam;ReportTypeParam_Property;ReportTypeParam}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.ReportTypeParam\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} ReportTypeParam: THIDPReportType;}\par
Many methods share common parameters. All properties with suffix Param are used as 
parameters in the implementation of the methods. So addressing the same report type 
with more than one method reduces code by first setting ReportTypeParam and then calling the methods. 
The Max*ListLength properties are interconnected to the Param properties. Setting the Param properties 
results in an update of the Max*ListLength properties to the correct value.
\par\page

#{\footnote # IDH_TJvHidDevice_SerialNumber}
${\footnote $ TJvHidDevice.SerialNumber}
K{\footnote K TJvHidDevice,SerialNumber;SerialNumber,TJvHidDevice;SerialNumber}
A{\footnote A TJvHidDevice_SerialNumber;SerialNumber_Property;SerialNumber}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.SerialNumber\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} SerialNumber: WideString;}\par
The serial number string of the device coming directly from the firmware of the device. 
It may be an empty string since it is optional. 
The string is in its original Unicode form.
\par\page

#{\footnote # IDH_TJvHidDevice_Tag}
${\footnote $ TJvHidDevice.Tag}
K{\footnote K TJvHidDevice,Tag;Tag,TJvHidDevice;Tag}
A{\footnote A TJvHidDevice_Tag;Tag_Property;Tag}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.Tag\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} Tag: Integer;}\par
A standard Tag property you can use to store any 32-Bit value.
\par\page

#{\footnote # IDH_TJvHidDevice_ThreadSleepTime}
${\footnote $ TJvHidDevice.ThreadSleepTime}
K{\footnote K TJvHidDevice,ThreadSleepTime;ThreadSleepTime,TJvHidDevice;ThreadSleepTime}
A{\footnote A TJvHidDevice_ThreadSleepTime;ThreadSleepTime_Property;ThreadSleepTime}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.ThreadSleepTime\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} ThreadSleepTime: Integer;}\par
This is the time in msecs that the thread implementing the {\uldb OnData\v IDH_TJvHidDevice_OnData>Main} event 
of the device sleeps. The thread only wakes up if a report arrives from the device or this 
timeout expires. Sleeping lowers the CPU usage of the thread, but introduces a lag for terminating the thread. 
You will have to find a balance between low CPU usage and fast thread termination.\line
The default is 100 msecs. The value can be set between 10 and 10.000.
\par\page

#{\footnote # IDH_TJvHidDevice_UsagePageParam}
${\footnote $ TJvHidDevice.UsagePageParam}
K{\footnote K TJvHidDevice,UsagePageParam;UsagePageParam,TJvHidDevice;UsagePageParam}
A{\footnote A TJvHidDevice_UsagePageParam;UsagePageParam_Property;UsagePageParam}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.UsagePageParam\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} UsagePageParam: TUsage;}\par
Many methods share common parameters. All properties with suffix Param are used as 
parameters in the implementation of the methods. So addressing the same usage page 
with more than one method reduces code by first setting UsagePageParam and then calling the methods. 
The Max*ListLength properties are interconnected to the Param properties. Setting the Param properties 
results in an update of the Max*ListLength properties to the correct value.
\par\page

#{\footnote # IDH_TJvHidDevice_UsageParam}
${\footnote $ TJvHidDevice.UsageParam}
K{\footnote K TJvHidDevice,UsageParam;UsageParam,TJvHidDevice;UsageParam}
A{\footnote A TJvHidDevice_UsageParam;UsageParam_Property;UsageParam}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.UsageParam\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} UsageParam: TUsage;}\par
Many methods share common parameters. All properties with suffix Param are used as 
parameters in the implementation of the methods. So addressing the same usage 
with more than one method reduces code by first setting UsageParam and then calling the methods. 
The Max*ListLength properties are interconnected to the Param properties. Setting the Param properties 
Results in an update of the Max*ListLength properties to the correct value.
\par\page

#{\footnote # IDH_TJvHidDevice_VendorName}
${\footnote $ TJvHidDevice.VendorName}
K{\footnote K TJvHidDevice,VendorName;VendorName,TJvHidDevice;VendorName}
A{\footnote A TJvHidDevice_VendorName;VendorName_Property;VendorName}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.VendorName\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} VendorName: WideString;}\par
The vendor name of the device coming directly from the firmware of the device. 
It may be an empty string since it is optional. 
The string is in its original Unicode form.
\par\page

#{\footnote # IDH_TJvHidDevice_CancelIO}
${\footnote $ TJvHidDevice.CancelIO}
K{\footnote K TJvHidDevice,CancelIO;CancelIO,TJvHidDevice;CancelIO}
A{\footnote A TJvHidDevice_CancelIO;CancelIO_Method;CancelIO}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.CancelIO\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} CancelIO({\b const} Mode: {\uldb TJvHidOpenExMode\v IDH_Type_TJvHidOpenExMode>Main}): Boolean;}\par
Cancels any pending asynchronous IO.
{\f0 CancelIO(omhRead)} cancels the IO on {\uldb HidOverlappedRead\v IDH_TJvHidDevice_HidOverlappedRead>Main} whereas 
{\f0 CancelIO(omhWrite)} cancels it on {\uldb HidOverlappedWrite\v IDH_TJvHidDevice_HidOverlappedWrite>Main}.\line
The return value is True for a successful cancellation. False otherwise.
\par\page

#{\footnote # IDH_Type_TJvHidOpenExMode}
${\footnote $ TJvHidOpenExMode}
K{\footnote K TJvHidOpenExMode}
A{\footnote A TJvHidOpenExMode_Type;TJvHidOpenExMode}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidOpenExMode\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b type} TJvHidOpenExMode = (omhRead, omhWrite);}\par
This type is used to address either {\uldb HidOverlappedRead\v IDH_TJvHidDevice_HidOverlappedRead>Main} or 
{\uldb HidOverlappedWrite\v IDH_TJvHidDevice_HidOverlappedWrite>Main} file handles.\line
It is used in 
{\uldb CancelIO\v IDH_TJvHidDevice_CancelIO>Main}, 
{\uldb CloseFileEx\v IDH_TJvHidDevice_CloseFileEx>Main} and 
{\uldb OpenFileEx\v IDH_TJvHidDevice_OpenFileEx>Main}.
\par\page

#{\footnote # IDH_TJvHidDevice_CloseFile}
${\footnote $ TJvHidDevice.CloseFile}
K{\footnote K TJvHidDevice,CloseFile;CloseFile,TJvHidDevice;CloseFile}
A{\footnote A TJvHidDevice_CloseFile;CloseFile_Method;CloseFile}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.CloseFile\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b procedure} CloseFile;}\par
Closes the file handle {\uldb HidFileHandle\v IDH_TJvHidDevice_HidFileHandle>Main} if opened. 
The file is automatically reopened when a method needs the file handle. 
Use {\uldb OpenFile\v IDH_TJvHidDevice_OpenFile>Main} to open the file if needed.\par
\par\page

#{\footnote # IDH_TJvHidDevice_CloseFileEx}
${\footnote $ TJvHidDevice.CloseFileEx}
K{\footnote K TJvHidDevice,CloseFileEx;CloseFileEx,TJvHidDevice;CloseFileEx}
A{\footnote A TJvHidDevice_CloseFileEx;CloseFileEx_Method;CloseFileEx}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.CloseFileEx\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b procedure} CloseFileEx({\b const} Mode: {\uldb TJvHidOpenExMode\v IDH_Type_TJvHidOpenExMode>Main});}\par
Closes either the file handle {\uldb HidOverlappedRead\v IDH_TJvHidDevice_HidOverlappedRead>Main} or 
{\uldb HidOverlappedWrite\v IDH_TJvHidDevice_HidOverlappedWrite>Main} if opened. 
CloseFileEx(omhRead) closes {\uldb HidOverlappedRead\v IDH_TJvHidDevice_HidOverlappedRead>Main} whereas 
CloseFileEx(omhWrite) closes {\uldb HidOverlappedWrite\v IDH_TJvHidDevice_HidOverlappedWrite>Main}.\line
The file is automatically reopened when a method needs the file handle. 
Use {\uldb OpenFileEx\v IDH_TJvHidDevice_OpenFileEx>Main} to open the file if needed.\par
\par\page

#{\footnote # IDH_TJvHidDevice_DeviceIoControl}
${\footnote $ TJvHidDevice.DeviceIoControl}
K{\footnote K TJvHidDevice,DeviceIoControl;DeviceIoControl,TJvHidDevice;DeviceIoControl}
A{\footnote A TJvHidDevice_DeviceIoControl;DeviceIoControl_Method;DeviceIoControl}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.DeviceIoControl\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} DeviceIoControl(IoControlCode: DWORD; InBuffer: Pointer; InSize: DWORD; 
OutBuffer: Pointer; OutSize: DWORD; {\b var} BytesReturned: DWORD): Boolean;}\par
Calls {\f0 Windows.DeviceIoControl({\uldb HidFileHandle\v IDH_TJvHidDevice_HidFileHandle>Main}, IoControlCode, InBuffer, InSize, OutBuffer, OutSize, BytesReturned, {\b nil});}\par
The return value comes from Windows.DeviceIoControl or {\uldb OpenFile\v IDH_TJvHidDevice_OpenFile>Main}.
\par\page

#{\footnote # IDH_TJvHidDevice_Create}
${\footnote $ TJvHidDevice.Create}
K{\footnote K TJvHidDevice,Create;Create,TJvHidDevice;Create}
K{\footnote K TJvHidDevice,Create;Create,TJvHidDevice;Create}
A{\footnote A TJvHidDevice_Create;Create_Method;Create}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.Create\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b constructor} Create;}\par
This is a dummy constructor. It simply always throws an exception. 
The reason for this is that a private {\f0 TJvHidDevice.Create} will not 
hide {\f0 TObject.Create}. So this dummy constructor will remind you not to 
create a TJvHidDevice object yourself.\par
The real constructor is the private CtlCreate.
\par\page

#{\footnote # IDH_TJvHidDevice_Destroy}
${\footnote $ TJvHidDevice.Destroy}
K{\footnote K TJvHidDevice,Destroy;Destroy,TJvHidDevice;Destroy}
K{\footnote K TJvHidDevice,Destroy;Destroy,TJvHidDevice;Destroy}
A{\footnote A TJvHidDevice_Destroy;Destroy_Method;Destroy}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.Destroy\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b destructor} Destroy; {\b override};}\par
The destructor of the TJvHidDevice class. The constructor is not exposed. 
Only {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController>Main} 
can (or should) create a TJvHidDevice object. 
If the device is checked out and plugged in the 
{\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController>Main} 
creates a new checked in object to represent this device.\line
As usual call the Free method of the object to destroy it. 
You may override the destructor if you like, but do not forget to call "{\f0 {\b inherited} Destroy;}" 
as last statement of the overridden destructor or the 
{\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController>Main} 
component cannot clean up correctly.
\par\page

#{\footnote # IDH_TJvHidDevice_FlushQueue}
${\footnote $ TJvHidDevice.FlushQueue}
K{\footnote K TJvHidDevice,FlushQueue;FlushQueue,TJvHidDevice;FlushQueue}
A{\footnote A TJvHidDevice_FlushQueue;FlushQueue_Method;FlushQueue}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.FlushQueue\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} FlushQueue: Boolean;}\par
Calls {\f0 HidD_FlushQueue({\uldb HidFileHandle\v IDH_TJvHidDevice_HidFileHandle>Main});} to delete all pending information from the input queue of the device.\par
The return value comes from HidD_FlushQueue or {\uldb OpenFile\v IDH_TJvHidDevice_OpenFile>Main}.
\par\page

#{\footnote # IDH_TJvHidDevice_GetButtonCaps}
${\footnote $ TJvHidDevice.GetButtonCaps}
K{\footnote K TJvHidDevice,GetButtonCaps;GetButtonCaps,TJvHidDevice;GetButtonCaps}
A{\footnote A TJvHidDevice_GetButtonCaps;GetButtonCaps_Method;GetButtonCaps}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.GetButtonCaps\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} GetButtonCaps(ButtonCaps: PHIDPButtonCaps; {\b var} Count: WORD): NTSTATUS;}\par
Calls {\f0 HidP_GetButtonCaps({\uldb ReportTypeParam\v IDH_TJvHidDevice_ReportTypeParam>Main}, ButtonCaps, Count, {\uldb PreparsedData\v IDH_TJvHidDevice_PreparsedData>Main});}\par
The return value value comes from HidP_GetButtonCaps or is {\f0 HIDP_STATUS_NULL} if the device 
is not plugged in.
\par\page

#{\footnote # IDH_TJvHidDevice_GetButtons}
${\footnote $ TJvHidDevice.GetButtons}
K{\footnote K TJvHidDevice,GetButtons;GetButtons,TJvHidDevice;GetButtons}
A{\footnote A TJvHidDevice_GetButtons;GetButtons_Method;GetButtons}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.GetButtons\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} GetButtons(UsageList: PUsage; {\b var} UsageLength: ULONG; {\b var} Report; ReportLength: ULONG): NTSTATUS;}\par
Calls {\f0 HidP_GetButtons({\uldb ReportTypeParam\v IDH_TJvHidDevice_ReportTypeParam>Main}, {\uldb UsagePageParam\v IDH_TJvHidDevice_UsagePageParam>Main}, {\uldb LinkCollectionParam\v IDH_TJvHidDevice_LinkCollectionParam>Main}, UsageList, UsageLength, {\uldb PreparsedData\v IDH_TJvHidDevice_PreparsedData>Main}, Report, ReportLength);}\par
The return value value comes from HidP_GetButtons or is {\f0 HIDP_STATUS_NULL} if the device 
is not plugged in.
\par\page

#{\footnote # IDH_TJvHidDevice_GetButtonsEx}
${\footnote $ TJvHidDevice.GetButtonsEx}
K{\footnote K TJvHidDevice,GetButtonsEx;GetButtonsEx,TJvHidDevice;GetButtonsEx}
A{\footnote A TJvHidDevice_GetButtonsEx;GetButtonsEx_Method;GetButtonsEx}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.GetButtonsEx\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} GetButtonsEx(UsageList: PUsageAndPage; {\b var} UsageLength: ULONG; {\b var} Report; ReportLength: ULONG): NTSTATUS;}\par
{\f0 TUsageAndPage = {\b record}\line
  Usage:     TUsage;\line
  UsagePage: TUsage;\line
{\b end};\par}
Calls {\f0 HidP_GetButtonsEx({\uldb ReportTypeParam\v IDH_TJvHidDevice_ReportTypeParam>Main}, {\uldb LinkCollectionParam\v IDH_TJvHidDevice_LinkCollectionParam>Main}, UsageList, UsageLength, {\uldb PreparsedData\v IDH_TJvHidDevice_PreparsedData>Main}, Report, ReportLength);}\par
The return value value comes from HidP_GetButtonsEx or is {\f0 HIDP_STATUS_NULL} if the device 
is not plugged in.
\par\page

#{\footnote # IDH_TJvHidDevice_GetData}
${\footnote $ TJvHidDevice.GetData}
K{\footnote K TJvHidDevice,GetData;GetData,TJvHidDevice;GetData}
A{\footnote A TJvHidDevice_GetData;GetData_Method;GetData}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.GetData\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} GetData(DataList: PHIDPData; {\b var} DataLength: ULONG; {\b var} Report; ReportLength: ULONG): NTSTATUS;}\par
Calls {\f0 HidP_GetData({\uldb ReportTypeParam\v IDH_TJvHidDevice_ReportTypeParam>Main}, DataList, DataLength, {\uldb PreparsedData\v IDH_TJvHidDevice_PreparsedData>Main}, Report, ReportLength);}\par
The return value value comes from HidP_GetData or is {\f0 HIDP_STATUS_NULL} if the device 
is not plugged in.
\par\page

#{\footnote # IDH_TJvHidDevice_GetFeature}
${\footnote $ TJvHidDevice.GetFeature}
K{\footnote K TJvHidDevice,GetFeature;GetFeature,TJvHidDevice;GetFeature}
A{\footnote A TJvHidDevice_GetFeature;GetFeature_Method;GetFeature}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.GetFeature\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} GetFeature({\b var} Report; {\b const} Size: Integer): Boolean;}\par
Reads in a feature report from the device. Set the first byte of the report buffer to the report ID you want to read. 
Add this extra byte to the length of the report to read.\par
Calls {\f0 HidD_GetFeature({\uldb HidFileHandle\v IDH_TJvHidDevice_HidFileHandle>Main}, Report, Size);}\par
The return value comes from HidD_GetFeature or {\uldb OpenFile\v IDH_TJvHidDevice_OpenFile>Main}.
\par\page

#{\footnote # IDH_TJvHidDevice_GetScaledUsageValue}
${\footnote $ TJvHidDevice.GetScaledUsageValue}
K{\footnote K TJvHidDevice,GetScaledUsageValue;GetScaledUsageValue,TJvHidDevice;GetScaledUsageValue}
A{\footnote A TJvHidDevice_GetScaledUsageValue;GetScaledUsageValue_Method;GetScaledUsageValue}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.GetScaledUsageValue\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} GetScaledUsageValue({\b var} UsageValue: Integer; {\b var} Report; ReportLength: ULONG): NTSTATUS;}\par
Calls {\f0 HidP_GetScaledUsageValue({\uldb ReportTypeParam\v IDH_TJvHidDevice_ReportTypeParam>Main}, {\uldb UsagePageParam\v IDH_TJvHidDevice_UsagePageParam>Main}, {\uldb LinkCollectionParam\v IDH_TJvHidDevice_LinkCollectionParam>Main}, 
{\uldb UsageParam\v IDH_TJvHidDevice_UsageParam>Main}, UsageValue, {\uldb PreparsedData\v IDH_TJvHidDevice_PreparsedData>Main}, Report, ReportLength);}\par
The return value value comes from HidP_GetScaledUsageValue or is {\f0 HIDP_STATUS_NULL} if the device 
is not plugged in.
\par\page

#{\footnote # IDH_TJvHidDevice_GetSpecificButtonCaps}
${\footnote $ TJvHidDevice.GetSpecificButtonCaps}
K{\footnote K TJvHidDevice,GetSpecificButtonCaps;GetSpecificButtonCaps,TJvHidDevice;GetSpecificButtonCaps}
A{\footnote A TJvHidDevice_GetSpecificButtonCaps;GetSpecificButtonCaps_Method;GetSpecificButtonCaps}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.GetSpecificButtonCaps\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} GetSpecificButtonCaps(ButtonCaps: PHIDPButtonCaps; {\b var} Count: WORD): NTSTATUS;}\par
Calls {\f0 HidP_GetSpecificButtonCaps({\uldb ReportTypeParam\v IDH_TJvHidDevice_ReportTypeParam>Main}, {\uldb UsagePageParam\v IDH_TJvHidDevice_UsagePageParam>Main}, {\uldb LinkCollectionParam\v IDH_TJvHidDevice_LinkCollectionParam>Main}, {\uldb UsageParam\v IDH_TJvHidDevice_UsageParam>Main}, ButtonCaps, Count, {\uldb PreparsedData\v IDH_TJvHidDevice_PreparsedData>Main});}\par
The return value value comes from HidP_GetSpecificButtonCaps or is {\f0 HIDP_STATUS_NULL} if the device 
is not plugged in.
\par\page

#{\footnote # IDH_TJvHidDevice_GetSpecificValueCaps}
${\footnote $ TJvHidDevice.GetSpecificValueCaps}
K{\footnote K TJvHidDevice,GetSpecificValueCaps;GetSpecificValueCaps,TJvHidDevice;GetSpecificValueCaps}
A{\footnote A TJvHidDevice_GetSpecificValueCaps;GetSpecificValueCaps_Method;GetSpecificValueCaps}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.GetSpecificValueCaps\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} GetSpecificValueCaps(ValueCaps: PHIDPValueCaps; {\b var} Count: WORD): NTSTATUS;}\par
Calls {\f0 HidP_GetSpecificValueCaps({\uldb ReportTypeParam\v IDH_TJvHidDevice_ReportTypeParam>Main}, {\uldb UsagePageParam\v IDH_TJvHidDevice_UsagePageParam>Main}, {\uldb LinkCollectionParam\v IDH_TJvHidDevice_LinkCollectionParam>Main}, {\uldb UsageParam\v IDH_TJvHidDevice_UsageParam>Main}, ValueCaps, Count, {\uldb PreparsedData\v IDH_TJvHidDevice_PreparsedData>Main});}\par
The return value value comes from HidP_GetSpecificValueCaps or is {\f0 HIDP_STATUS_NULL} if the device 
is not plugged in.
\par\page

#{\footnote # IDH_TJvHidDevice_GetUsages}
${\footnote $ TJvHidDevice.GetUsages}
K{\footnote K TJvHidDevice,GetUsages;GetUsages,TJvHidDevice;GetUsages}
A{\footnote A TJvHidDevice_GetUsages;GetUsages_Method;GetUsages}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.GetUsages\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} GetUsages(UsageList: PUsage; {\b var} UsageLength: ULONG; {\b var} Report; ReportLength: ULONG): NTSTATUS;}\par
Calls {\f0 HidP_GetUsages({\uldb ReportTypeParam\v IDH_TJvHidDevice_ReportTypeParam>Main}, {\uldb UsagePageParam\v IDH_TJvHidDevice_UsagePageParam>Main}, {\uldb LinkCollectionParam\v IDH_TJvHidDevice_LinkCollectionParam>Main}, UsageList, UsageLength, {\uldb PreparsedData\v IDH_TJvHidDevice_PreparsedData>Main}, Report, ReportLength);}\par
The return value value comes from HidP_GetUsages or is {\f0 HIDP_STATUS_NULL} if the device 
is not plugged in.
\par\page

#{\footnote # IDH_TJvHidDevice_GetUsagesEx}
${\footnote $ TJvHidDevice.GetUsagesEx}
K{\footnote K TJvHidDevice,GetUsagesEx;GetUsagesEx,TJvHidDevice;GetUsagesEx}
A{\footnote A TJvHidDevice_GetUsagesEx;GetUsagesEx_Method;GetUsagesEx}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.GetUsagesEx\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} GetUsagesEx(UsageList: PUsageAndPage; {\b var} UsageLength: ULONG; {\b var} Report; ReportLength: ULONG): NTSTATUS;}\par
{\f0 TUsageAndPage = {\b record}\line
  Usage:     TUsage;\line
  UsagePage: TUsage;\line
{\b end};\par}
Calls {\f0 HidP_GetUsagesEx({\uldb ReportTypeParam\v IDH_TJvHidDevice_ReportTypeParam>Main}, {\uldb LinkCollectionParam\v IDH_TJvHidDevice_LinkCollectionParam>Main}, UsageList, UsageLength, {\uldb PreparsedData\v IDH_TJvHidDevice_PreparsedData>Main}, Report, ReportLength);}\par
The return value value comes from HidP_GetUsagesEx or is {\f0 HIDP_STATUS_NULL} if the device 
is not plugged in.
\par\page

#{\footnote # IDH_TJvHidDevice_GetUsageValue}
${\footnote $ TJvHidDevice.GetUsageValue}
K{\footnote K TJvHidDevice,GetUsageValue;GetUsageValue,TJvHidDevice;GetUsageValue}
A{\footnote A TJvHidDevice_GetUsageValue;GetUsageValue_Method;GetUsageValue}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.GetUsageValue\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} GetUsageValue({\b var} UsageValue: ULONG; {\b var} Report; ReportLength: ULONG): NTSTATUS;}\par
Calls {\f0 HidP_GetUsageValue({\uldb ReportTypeParam\v IDH_TJvHidDevice_ReportTypeParam>Main}, {\uldb UsagePageParam\v IDH_TJvHidDevice_UsagePageParam>Main}, {\uldb LinkCollectionParam\v IDH_TJvHidDevice_LinkCollectionParam>Main}, {\uldb UsageParam\v IDH_TJvHidDevice_UsageParam>Main}, UsageValue, {\uldb PreparsedData\v IDH_TJvHidDevice_PreparsedData>Main}, Report, ReportLength);}\par
The return value value comes from HidP_GetUsageValue or is {\f0 HIDP_STATUS_NULL} if the device 
is not plugged in.
\par\page

#{\footnote # IDH_TJvHidDevice_GetUsageValueArray}
${\footnote $ TJvHidDevice.GetUsageValueArray}
K{\footnote K TJvHidDevice,GetUsageValueArray;GetUsageValueArray,TJvHidDevice;GetUsageValueArray}
A{\footnote A TJvHidDevice_GetUsageValueArray;GetUsageValueArray_Method;GetUsageValueArray}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.GetUsageValueArray\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} GetUsageValueArray(UsageValue: PChar; UsageValueByteLength: WORD; {\b var} Report; ReportLength: ULONG): NTSTATUS;}\par
Calls {\f0 HidP_GetUsageValueArray({\uldb ReportTypeParam\v IDH_TJvHidDevice_ReportTypeParam>Main}, {\uldb UsagePageParam\v IDH_TJvHidDevice_UsagePageParam>Main}, {\uldb LinkCollectionParam\v IDH_TJvHidDevice_LinkCollectionParam>Main}, {\uldb UsageParam\v IDH_TJvHidDevice_UsageParam>Main}, UsageValue, UsageValueByteLength, {\uldb PreparsedData\v IDH_TJvHidDevice_PreparsedData>Main}, Report, ReportLength);}\par
The return value value comes from HidP_GetUsageValueArray or is {\f0 HIDP_STATUS_NULL} if the device 
is not plugged in.
\par\page

#{\footnote # IDH_TJvHidDevice_GetValueCaps}
${\footnote $ TJvHidDevice.GetValueCaps}
K{\footnote K TJvHidDevice,GetValueCaps;GetValueCaps,TJvHidDevice;GetValueCaps}
A{\footnote A TJvHidDevice_GetValueCaps;GetValueCaps_Method;GetValueCaps}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.GetValueCaps\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} GetValueCaps(ValueCaps: PHIDPValueCaps; {\b var} Count: WORD): NTSTATUS;}\par
Calls {\f0 HidP_GetValueCaps({\uldb ReportTypeParam\v IDH_TJvHidDevice_ReportTypeParam>Main}, ValueCaps, Count, {\uldb PreparsedData\v IDH_TJvHidDevice_PreparsedData>Main});}\par
The return value value comes from HidP_GetValueCaps or is {\f0 HIDP_STATUS_NULL} if the device 
is not plugged in.
\par\page

#{\footnote # IDH_TJvHidDevice_OpenFile}
${\footnote $ TJvHidDevice.OpenFile}
K{\footnote K TJvHidDevice,OpenFile;OpenFile,TJvHidDevice;OpenFile}
A{\footnote A TJvHidDevice_OpenFile;OpenFile_Method;OpenFile}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.OpenFile\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} OpenFile: Boolean;}\par
Opens the file handle {\uldb HidFileHandle\v IDH_TJvHidDevice_HidFileHandle>Main} if not already opened. 
The file is closed with {\uldb CloseFile\v IDH_TJvHidDevice_CloseFile>Main}.\par
The file is opened with read and write access. If this fails then the file 
is opened with {\b neither} read {\b nor} write access! This will allow 
several HID functions to succeed on a device already opened by Windows 2000 
exclusively. Namely mice and keyboards are opened exclusively. 
{\uldb ReadFile\v IDH_TJvHidDevice_ReadFile>Main} and 
{\uldb WriteFile\v IDH_TJvHidDevice_WriteFile>Main} will fail of course, but 
{\uldb GetFeature\v IDH_TJvHidDevice_GetFeature>Main} and 
{\uldb SetFeature\v IDH_TJvHidDevice_SetFeature>Main} 
will succeed.
The return value is True for an already open or a successfully opened file.
\par\page

#{\footnote # IDH_TJvHidDevice_OpenFileEx}
${\footnote $ TJvHidDevice.OpenFileEx}
K{\footnote K TJvHidDevice,OpenFileEx;OpenFileEx,TJvHidDevice;OpenFileEx}
A{\footnote A TJvHidDevice_OpenFileEx;OpenFileEx_Method;OpenFileEx}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.OpenFileEx\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} OpenFileEx({\b const} Mode: {\uldb TJvHidOpenExMode\v IDH_Type_TJvHidOpenExMode>Main}): Boolean;}\par
Opens either the file handle {\uldb HidOverlappedRead\v IDH_TJvHidDevice_HidOverlappedRead>Main} or 
{\uldb HidOverlappedWrite\v IDH_TJvHidDevice_HidOverlappedWrite>Main} if closed. 
OpenFileEx(omhRead) opens {\uldb HidOverlappedRead\v IDH_TJvHidDevice_HidOverlappedRead>Main} whereas 
OpenFileEx(omhWrite) opens {\uldb HidOverlappedWrite\v IDH_TJvHidDevice_HidOverlappedWrite>Main}.\line
The file is closed with {\uldb CloseFileEx\v IDH_TJvHidDevice_CloseFileEx>Main}.\par
The return value is True for an already open or a successfully opened file.
\par\page

#{\footnote # IDH_TJvHidDevice_ReadFile}
${\footnote $ TJvHidDevice.ReadFile}
K{\footnote K TJvHidDevice,ReadFile;ReadFile,TJvHidDevice;ReadFile}
A{\footnote A TJvHidDevice_ReadFile;ReadFile_Method;ReadFile}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.ReadFile\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} ReadFile({\b var} Report; ToRead: DWORD; {\b var} BytesRead: DWORD): Boolean;}\par
Calls {\f0 Windows.ReadFile({\uldb HidFileHandle\v IDH_TJvHidDevice_HidFileHandle>Main}, Report, ToRead, BytesRead, {\b nil});}\par
The return value comes from Windows.ReadFile or {\uldb OpenFile\v IDH_TJvHidDevice_OpenFile>Main}.
\par\page

#{\footnote # IDH_TJvHidDevice_ReadFileEx}
${\footnote $ TJvHidDevice.ReadFileEx}
K{\footnote K TJvHidDevice,ReadFileEx;ReadFileEx,TJvHidDevice;ReadFileEx}
A{\footnote A TJvHidDevice_ReadFileEx;ReadFileEx_Method;ReadFileEx}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.ReadFileEx\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} ReadFileEx({\b var} Report; ToRead: DWORD; CallBack: TPROverlappedCompletionRoutine): Boolean;}\par
Calls {\f0 Windows.ReadFileEx({\uldb HidOverlappedRead\v IDH_TJvHidDevice_HidOverlappedRead>Main}, Report, ToRead, Ovl, CallBack);}\par
The return value comes from Windows.ReadFileEx or {\uldb OpenFileEx\v IDH_TJvHidDevice_OpenFileEx>Main}.\line
Ovl is internal. Ovl.hEvent is initialized to {\f0 Ovl.hEvent := DWORD(Self);}.
\par\page

#{\footnote # IDH_TJvHidDevice_SetButtons}
${\footnote $ TJvHidDevice.SetButtons}
K{\footnote K TJvHidDevice,SetButtons;SetButtons,TJvHidDevice;SetButtons}
A{\footnote A TJvHidDevice_SetButtons;SetButtons_Method;SetButtons}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.SetButtons\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} SetButtons(UsageList: PUsage; {\b var} UsageLength: ULONG; {\b var} Report; ReportLength: ULONG): NTSTATUS;}\par
Calls {\f0 HidP_SetButtons({\uldb ReportTypeParam\v IDH_TJvHidDevice_ReportTypeParam>Main}, {\uldb UsagePageParam\v IDH_TJvHidDevice_UsagePageParam>Main}, {\uldb LinkCollectionParam\v IDH_TJvHidDevice_LinkCollectionParam>Main}, UsageList, UsageLength, {\uldb PreparsedData\v IDH_TJvHidDevice_PreparsedData>Main}, Report, ReportLength);}\par
The return value value comes from HidP_SetButtons or is {\f0 HIDP_STATUS_NULL} if the device 
is not plugged in.
\par\page

#{\footnote # IDH_TJvHidDevice_SetData}
${\footnote $ TJvHidDevice.SetData}
K{\footnote K TJvHidDevice,SetData;SetData,TJvHidDevice;SetData}
A{\footnote A TJvHidDevice_SetData;SetData_Method;SetData}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.SetData\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} SetData(DataList: PHIDPData; {\b var} DataLength: ULONG; {\b var} Report; ReportLength: ULONG): NTSTATUS;}\par
Calls {\f0 HidP_SetData({\uldb ReportTypeParam\v IDH_TJvHidDevice_ReportTypeParam>Main}, DataList, DataLength, {\uldb PreparsedData\v IDH_TJvHidDevice_PreparsedData>Main}, Report, ReportLength);}\par
The return value value comes from HidP_SetData or is {\f0 HIDP_STATUS_NULL} if the device 
is not plugged in.
\par\page

#{\footnote # IDH_TJvHidDevice_SetFeature}
${\footnote $ TJvHidDevice.SetFeature}
K{\footnote K TJvHidDevice,SetFeature;SetFeature,TJvHidDevice;SetFeature}
A{\footnote A TJvHidDevice_SetFeature;SetFeature_Method;SetFeature}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.SetFeature\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} SetFeature({\b var} Report; {\b const} Size: Integer): Boolean;}\par
Writes a feature report to the device. Set the first byte of the report buffer to the report ID you want to write. 
Add this extra byte to the length of the report to write.\par
Calls {\f0 HidD_SetFeature({\uldb HidFileHandle\v IDH_TJvHidDevice_HidFileHandle>Main}, Report, Size);}\par
The return value comes from HidD_SetFeature or {\uldb OpenFile\v IDH_TJvHidDevice_OpenFile>Main}.
\par\page

#{\footnote # IDH_TJvHidDevice_SetScaledUsageValue}
${\footnote $ TJvHidDevice.SetScaledUsageValue}
K{\footnote K TJvHidDevice,SetScaledUsageValue;SetScaledUsageValue,TJvHidDevice;SetScaledUsageValue}
A{\footnote A TJvHidDevice_SetScaledUsageValue;SetScaledUsageValue_Method;SetScaledUsageValue}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.SetScaledUsageValue\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} function SetScaledUsageValue(UsageValue: Integer; {\b var} Report; ReportLength: ULong): NTSTATUS;}\par
Calls {\f0 HidP_SetScaledUsageValue({\uldb ReportTypeParam\v IDH_TJvHidDevice_ReportTypeParam>Main}, {\uldb UsagePageParam\v IDH_TJvHidDevice_UsagePageParam>Main}, {\uldb LinkCollectionParam\v IDH_TJvHidDevice_LinkCollectionParam>Main}, {\uldb UsageParam\v IDH_TJvHidDevice_UsageParam>Main}, UsageValue, {\uldb PreparsedData\v IDH_TJvHidDevice_PreparsedData>Main}, Report, ReportLength);}\par
The return value value comes from HidP_SetScaledUsageValue or is {\f0 HIDP_STATUS_NULL} if the device 
is not plugged in.
\par\page

#{\footnote # IDH_TJvHidDevice_SetUsages}
${\footnote $ TJvHidDevice.SetUsages}
K{\footnote K TJvHidDevice,SetUsages;SetUsages,TJvHidDevice;SetUsages}
A{\footnote A TJvHidDevice_SetUsages;SetUsages_Method;SetUsages}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.SetUsages\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} SetUsages(UsageList: PUsage; {\b var} UsageLength: ULong; {\b var} Report; ReportLength: ULong): NTSTATUS;}\par
Calls {\f0 HidP_SetUsages({\uldb ReportTypeParam\v IDH_TJvHidDevice_ReportTypeParam>Main}, {\uldb UsagePageParam\v IDH_TJvHidDevice_UsagePageParam>Main}, {\uldb LinkCollectionParam\v IDH_TJvHidDevice_LinkCollectionParam>Main}, UsageList, UsageLength, {\uldb PreparsedData\v IDH_TJvHidDevice_PreparsedData>Main}, Report, ReportLength);}\par
The return value value comes from HidP_SetUsages or is {\f0 HIDP_STATUS_NULL} if the device 
is not plugged in.
\par\page

#{\footnote # IDH_TJvHidDevice_SetUsageValue}
${\footnote $ TJvHidDevice.SetUsageValue}
K{\footnote K TJvHidDevice,SetUsageValue;SetUsageValue,TJvHidDevice;SetUsageValue}
A{\footnote A TJvHidDevice_SetUsageValue;SetUsageValue_Method;SetUsageValue}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.SetUsageValue\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} SetUsageValue(UsageValue: ULONG; {\b var} Report; ReportLength: ULONG): NTSTATUS;}\par
Calls {\f0 HidP_SetUsageValue({\uldb ReportTypeParam\v IDH_TJvHidDevice_ReportTypeParam>Main}, {\uldb UsagePageParam\v IDH_TJvHidDevice_UsagePageParam>Main}, {\uldb LinkCollectionParam\v IDH_TJvHidDevice_LinkCollectionParam>Main}, {\uldb UsageParam\v IDH_TJvHidDevice_UsageParam>Main}, UsageValue, {\uldb PreparsedData\v IDH_TJvHidDevice_PreparsedData>Main}, Report, ReportLength);}\par
The return value value comes from HidP_SetUsageValue or is {\f0 HIDP_STATUS_NULL} if the device 
is not plugged in.
\par\page

#{\footnote # IDH_TJvHidDevice_SetUsageValueArray}
${\footnote $ TJvHidDevice.SetUsageValueArray}
K{\footnote K TJvHidDevice,SetUsageValueArray;SetUsageValueArray,TJvHidDevice;SetUsageValueArray}
A{\footnote A TJvHidDevice_SetUsageValueArray;SetUsageValueArray_Method;SetUsageValueArray}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.SetUsageValueArray\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} SetUsageValueArray(UsageValue: PChar; UsageValueByteLength: WORD; {\b var} Report; ReportLength: ULONG): NTSTATUS;}\par
Calls {\f0 HidP_SetUsageValueArray({\uldb ReportTypeParam\v IDH_TJvHidDevice_ReportTypeParam>Main}, {\uldb UsagePageParam\v IDH_TJvHidDevice_UsagePageParam>Main}, {\uldb LinkCollectionParam\v IDH_TJvHidDevice_LinkCollectionParam>Main}, {\uldb UsageParam\v IDH_TJvHidDevice_UsageParam>Main}, UsageValue, UsageValueByteLength, {\uldb PreparsedData\v IDH_TJvHidDevice_PreparsedData>Main}, Report, ReportLength);}\par
The return value value comes from HidP_SetUsageValueArray or is {\f0 HIDP_STATUS_NULL} if the device 
is not plugged in.
\par\page

#{\footnote # IDH_TJvHidDevice_UnsetButtons}
${\footnote $ TJvHidDevice.UnsetButtons}
K{\footnote K TJvHidDevice,UnsetButtons;UnsetButtons,TJvHidDevice;UnsetButtons}
A{\footnote A TJvHidDevice_UnsetButtons;UnsetButtons_Method;UnsetButtons}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.UnsetButtons\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} UnsetButtons(UsageList: PUsage; {\b var} UsageLength: ULONG; {\b var} Report; ReportLength: ULONG): NTSTATUS;}\par
Calls {\f0 HidP_UnsetButtons({\uldb ReportTypeParam\v IDH_TJvHidDevice_ReportTypeParam>Main}, {\uldb UsagePageParam\v IDH_TJvHidDevice_UsagePageParam>Main}, {\uldb LinkCollectionParam\v IDH_TJvHidDevice_LinkCollectionParam>Main}, UsageList, UsageLength, {\uldb PreparsedData\v IDH_TJvHidDevice_PreparsedData>Main}, Report, ReportLength);}\par
The return value value comes from HidP_UnsetButtons or is {\f0 HIDP_STATUS_NULL} if the device 
is not plugged in.
\par\page

#{\footnote # IDH_TJvHidDevice_UnsetUsages}
${\footnote $ TJvHidDevice.UnsetUsages}
K{\footnote K TJvHidDevice,UnsetUsages;UnsetUsages,TJvHidDevice;UnsetUsages}
A{\footnote A TJvHidDevice_UnsetUsages;UnsetUsages_Method;UnsetUsages}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.UnsetUsages\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} UnsetUsages(UsageList: PUsage; {\b var} UsageLength: ULONG; {\b var} Report; ReportLength: ULONG): NTSTATUS;}\par
Calls {\f0 HidP_UnsetUsages({\uldb ReportTypeParam\v IDH_TJvHidDevice_ReportTypeParam>Main}, {\uldb UsagePageParam\v IDH_TJvHidDevice_UsagePageParam>Main}, {\uldb LinkCollectionParam\v IDH_TJvHidDevice_LinkCollectionParam>Main}, UsageList, UsageLength, {\uldb PreparsedData\v IDH_TJvHidDevice_PreparsedData>Main}, Report, ReportLength);}\par
The return value value comes from HidP_UnsetUsages or is {\f0 HIDP_STATUS_NULL} if the device 
is not plugged in.
\par\page

#{\footnote # IDH_TJvHidDevice_WriteFile}
${\footnote $ TJvHidDevice.WriteFile}
K{\footnote K TJvHidDevice,WriteFile;WriteFile,TJvHidDevice;WriteFile}
A{\footnote A TJvHidDevice_WriteFile;WriteFile_Method;WriteFile}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.WriteFile\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} WriteFile({\b var} Report; ToWrite: DWORD; {\b var} BytesWritten: DWORD): Boolean;}\par
Calls {\f0 Windows.WriteFile({\uldb HidFileHandle\v IDH_TJvHidDevice_HidFileHandle>Main}, Report, ToWrite, BytesWritten, {\b nil});}\par
The return value comes from Windows.WriteFile or {\uldb OpenFile\v IDH_TJvHidDevice_OpenFile>Main}.
\par\page

#{\footnote # IDH_TJvHidDevice_WriteFileEx}
${\footnote $ TJvHidDevice.WriteFileEx}
K{\footnote K TJvHidDevice,WriteFileEx;WriteFileEx,TJvHidDevice;WriteFileEx}
A{\footnote A TJvHidDevice_WriteFileEx;WriteFileEx_Method;WriteFileEx}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.WriteFileEx\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} WriteFileEx({\b var} Report; ToWrite: DWORD; CallBack: TPROverlappedCompletionRoutine): Boolean;}\par
Calls {\f0 Windows.WriteFileEx({\uldb HidOverlappedWrite\v IDH_TJvHidDevice_HidOverlappedWrite>Main}, Report, ToWrite, Ovl, CallBack);}\par
The return value comes from Windows.WriteFileEx or {\uldb OpenFileEx\v IDH_TJvHidDevice_OpenFile>Main}.
Ovl is internal. Ovl.hEvent is initialized to {\f0 Ovl.hEvent := DWORD(Self);}.
\par\page

#{\footnote # IDH_TJvHidDevice_CheckOut}
${\footnote $ TJvHidDevice.CheckOut}
K{\footnote K TJvHidDevice,CheckOut;CheckOut,TJvHidDevice;CheckOut}
A{\footnote A TJvHidDevice_CheckOut;CheckOut_Method;CheckOut}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.CheckOut\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Deklaration\b0\par
{\f0 {\b function} CheckOut: Boolean;}\par
Allows to check out the device inside for example the 
{\uldb OnEnumerate\v IDH_TJvHidDeviceController_OnEnumerate>Main}-Event.
\par\page

#{\footnote # IDH_TJvHidDevice_GetExtendedAttributes}
${\footnote $ TJvHidDevice.GetExtendedAttributes}
K{\footnote K TJvHidDevice,GetExtendedAttributes;GetExtendedAttributes,TJvHidDevice;GetExtendedAttributes}
A{\footnote A TJvHidDevice_GetExtendedAttributes;GetExtendedAttributes_Method;GetExtendedAttributes}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.GetExtendedAttributes\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Deklaration\b0\par
{\f0 {\b function} CheckOut: Boolean;}\par
{\f0 {\b function} GetExtendedAttributes(ReportType: THIDPReportType; DataIndex: Word; 
Attributes: PHIDPExtendedAttributes; {\b var} LengthAttributes: ULONG): NTSTATUS;}\par
The method wraps the HID function HidP_GetExtendedAttributes. Since the function has been 
introduced in Windows 2000, the method fails for Win 9x.
\par\page

#{\footnote # IDH_TJvHidDevice_InitializeReportForID}
${\footnote $ TJvHidDevice.InitializeReportForID}
K{\footnote K TJvHidDevice,InitializeReportForID;InitializeReportForID,TJvHidDevice;InitializeReportForID}
A{\footnote A TJvHidDevice_InitializeReportForID;InitializeReportForID_Method;InitializeReportForID}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.InitializeReportForID\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Deklaration\b0\par
{\f0 {\b function} InitializeReportForID(ReportType: THIDPReportType; ReportID: Byte; 
{\b var} Report; ReportLength: ULONG): NTSTATUS;}\par
The method wraps the HID function HidP_InitializeReportForID. Since the function has been 
introduced in Windows 2000, the method fails for Windows 9x.\par
The function initializes the Report to the empty state. Usages can have an empty value 
different from 0.
\par\page

#{\footnote # IDH_TJvHidDevice_GetInputReport}
${\footnote $ TJvHidDevice.GetInputReport}
K{\footnote K TJvHidDevice,GetInputReport;GetInputReport,TJvHidDevice;GetInputReport}
A{\footnote A TJvHidDevice_GetInputReport;GetInputReport_Method;GetInputReport}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.GetInputReport\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Deklaration\b0\par
{\f0 {\b function} GetInputReport({\b var} Report; {\b const} Size: ULONG): Boolean;}\par
The method wraps the HID function HidD_GetInputReport. Since the function has been 
introduced in Windows XP, the method fails for Windows 9x and 2000.\par
The function reads a specific report from the device. For that the ReportID of Report 
has to be set to the desired value.
\par\page

#{\footnote # IDH_TJvHidDevice_SetOutputReport}
${\footnote $ TJvHidDevice.SetOutputReport}
K{\footnote K TJvHidDevice,SetOutputReport;SetOutputReport,TJvHidDevice;SetOutputReport}
A{\footnote A TJvHidDevice_SetOutputReport;SetOutputReport_Method;SetOutputReport}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.SetOutputReport\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Deklaration\b0\par
{\f0 {\b function} SetOutputReport({\b var} Report; {\b const} Size: ULONG): Boolean;}\par
The method wraps the HID function HidD_SetOutputReport. Since the function has been 
introduced in Windows XP, the method fails for Windows 9x and 2000.\par
The function writes a specific report the device. The difference to {\uldb WriteFile\v IDH_TJvHidDevice_WriteFile>Main} 
is that USB output transfers are used. WriteFile may use control transfers.
\par\page

#{\footnote # IDH_TJvHidDevice_OnData}
${\footnote $ TJvHidDevice.OnData}
K{\footnote K TJvHidDevice,OnData;OnData,TJvHidDevice;OnData}
A{\footnote A TJvHidDevice_OnData;OnData_Event;OnData}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.OnData\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 TJvHidDataEvent = {\b procedure}({\b const} HidDev: {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}; ReportID: Byte; 
{\b const} Data: Pointer; Size: Word) {\b of} {\b object};}\par
This event automatically starts a thread to read the device. Each time the device sends a report 
the event fires and presents the report. The thread only runs as long as the device is checked out. 
This also implies that checked in devices presented in the {\uldb OnEnumerate\v IDH_TJvHidDeviceController_OnEnumerate>Main} event have no thread running.\par
{\f0 HidDev} is the originating device. {\f0 ReportID} tells which report you got. The value is #0 for devices which can only send a single report. 
{\f0 Data} points to the bytes of the report. {\f0 Size} tells the number of bytes in Data.\par
Do not keep the Data pointer. The area is overwritten for each new report.\par
The thread is started if either the device is checked out and OnData is already assigned via {\uldb OnDeviceData\v IDH_TJvHidDeviceController_OnDeviceData>Main} 
or on assignment for an already checked out device. The thread is not started for checked in devices while enumerated via 
{\uldb Enumerate\v IDH_TJvHidDeviceController_Enumerate>Main}. It is also not started if {\uldb HasReadWriteAccess\v IDH_TJvHidDevice_HasReadWriteAccess>Main} 
has the value {\f0 False}. The thread is terminated on check in or Free.\par
{\uldb ThreadSleepTime\v IDH_TJvHidDevice_ThreadSleepTime>Main} is used to wake up the thread regularly to see if it should terminate. 
This timeout creates a lag when the thread is terminated because the device object is checked in or freed. 
You will have to trade in more lag for less thread CPU consumption. The default of 100 msec is a good tradeoff.\par
You can assign the event function directly at runtime or for all devices at design time with {\uldb OnDeviceData\v IDH_TJvHidDeviceController_OnDeviceData>Main}.
\par\page

#{\footnote # IDH_TJvHidDevice_OnDataError}
${\footnote $ TJvHidDevice.OnDataError}
K{\footnote K TJvHidDevice,OnDataError;OnDataError,TJvHidDevice;OnDataError}
A{\footnote A TJvHidDevice_OnDataError;OnDataError_Event;OnDataError}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.OnDataError\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 TJvHidDataErrorEvent = {\b procedure}({\b const} HidDev: {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}; 
Error: DWORD) {\b of} {\b object};}\par
The event occurs if {\uldb OnData\v IDH_TJvHidDevice_OnData>Main} encounters a read error on calling ReadFileEx. 
The parameters of the event are the device which encountered the read error and the error value 
gathered through GetLastError.
\par\page

#{\footnote # IDH_TJvHidDevice_OnUnplug}
${\footnote $ TJvHidDevice.OnUnplug}
K{\footnote K TJvHidDevice,OnUnplug;OnUnplug,TJvHidDevice;OnUnplug}
A{\footnote A TJvHidDevice_OnUnplug;OnUnplug_Event;OnUnplug}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDevice.OnUnplug\b0}   \line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 TJvHidUnplugEvent = {\b procedure}(HidDev: {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}) {\b of} {\b object};}\par
This event occurs if you pull the plug of the device. It is sent even for checked in devices. 
The object is already in unplugged state. No method will work.\line
You can assign the event function directly at runtime or for all devices at design time with {\uldb OnDeviceUnplug\v IDH_TJvHidDeviceController_OnDeviceUnplug>Main}.
\par\page

#{\footnote # IDH_Class_TJvHidDeviceController}
${\footnote $ TJvHidDeviceController}
K{\footnote K TJvHidDeviceController}
A{\footnote A TJvHidDeviceController_Object;TJvHidDeviceController}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\f1\fs28  \cf2 TJvHidDeviceController Object}\line
{\fs20{\ul Hierarchy\v IDH_Anym_3FAMT_2}    {\uldb Properties\v pme_cp_TJvHidDeviceController>pme}   {\uldb Methods\v pme_cm_TJvHidDeviceController>pme}   {\uldb Events\v pme_ce_TJvHidDeviceController>pme}\tab{\uldb Other\v pme_ce_Other>pme}}\par\pard}
\b Declaration\b0\par
{\f0 TJvHidDeviceController = \b class\b0 (TComponent)}\par\pard\sa0\sb0{
#{\footnote # IDH_ClassTopic_TJvHidDeviceController_Properties}}
The main purpose of a TJvHidDeviceController object is to handle TJvHidDevice objects. 
For each plugged HID device the controller creates a TJvHidDevice object to represent the device. 
The controller monitors device plugs and unplugs. On device plug a new TJvHidDevice object is created. 
On unplug the object is not destroyed but is signalled and goes to an unplugged state.\line
The methods of TJvHidDeviceController are mainly for handing out TJvHidDevice objects by various criteria.\line
There is no need to instantiate more than one TJvHidDeviceController per program. Trying to drop a 
second one on a form of your projects throws an exception to remind you.\par
The component even works in Windows 95 and Windows NT which have no USB support. 
It simply never finds a HID device to handle. 
This is an important feature for programs which manage HID and non-HID versions of devices. 
Sound devices are an example for that.
\par\page

#{\footnote # pme_cp_TJvHidDeviceController}
${\footnote $ Properties for TJvHidDeviceController}
+{\footnote + Auto}
\sa50\sb50{\keepn{\f1\fs20\cf2\b{\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController>Main} Properties\b0}\line
{\fs20{\ul Legend\v IDH_Legend}}\par\pard}
{\f1\tx300\b In TJvHidDeviceController\b0\line
\{bmct published.bmp\}\tab{\uldb DevThreadSleepTime\v IDH_TJvHidDeviceController_DevThreadSleepTime>Main}\line
\{bmct readonly.bmp\}\tab{\uldb HidGuid\v IDH_TJvHidDeviceController_HidGuid>Main}\line
\{bmct readonly.bmp\}\tab{\uldb NumCheckedInDevices\v IDH_TJvHidDeviceController_NumCheckedInDevices>Main}\line
\{bmct readonly.bmp\}\tab{\uldb NumCheckedOutDevices\v IDH_TJvHidDeviceController_NumCheckedOutDevices>Main}\line
\{bmct readonly.bmp\}\tab{\uldb NumUnpluggedDevices\v IDH_TJvHidDeviceController_NumUnpluggedDevices>Main}\line
\{bmct published.bmp\}\tab{\uldb Version\v IDH_TJvHidDeviceController_Version>Main}
}\par\page

#{\footnote # pme_cm_TJvHidDeviceController}
${\footnote $ Methods for TJvHidDeviceController}
+{\footnote + Auto}
\sa50\sb50{\keepn{\f1\fs20\cf2\b{\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController>Main} Methods\b0}\line
{\fs20{\ul Legend\v IDH_Legend}}\par\pard}
{\f1\tx300\b In TJvHidDeviceController\b0\line
\{bmct empty.bmp\}\tab{\uldb CheckIn\v IDH_TJvHidDeviceController_CheckIn>Main}\line
\{bmct empty.bmp\}\tab{\uldb CheckOut\v IDH_TJvHidDeviceController_CheckOut>Main}\line
\{bmct empty.bmp\}\tab{\uldb CheckOutByClass\v IDH_TJvHidDeviceController_CheckOutByClass>Main}\line
\{bmct empty.bmp\}\tab{\uldb CheckOutByID\v IDH_TJvHidDeviceController_CheckOutByID>Main}\line
\{bmct empty.bmp\}\tab{\uldb CheckOutByIndex\v IDH_TJvHidDeviceController_CheckOutByIndex>Main}\line
\{bmct empty.bmp\}\tab{\uldb CheckOutByProductName\v IDH_TJvHidDeviceController_CheckOutByProductName>Main}\line
\{bmct empty.bmp\}\tab{\uldb CheckOutByVendorName\v IDH_TJvHidDeviceController_CheckOutByVendorName>Main}\line
\{bmct empty.bmp\}\tab{\uldb CheckOutByCallback\v IDH_TJvHidDeviceController_CheckOutByCallback>Main}\line
\{bmct empty.bmp\}\tab{\uldb Create\v IDH_TJvHidDeviceController_Create>Main}\line
\{bmct empty.bmp\}\tab{\uldb CountByClass\v IDH_TJvHidDeviceController_CountByClass>Main}\line
\{bmct empty.bmp\}\tab{\uldb CountByID\v IDH_TJvHidDeviceController_CountByID>Main}\line
\{bmct empty.bmp\}\tab{\uldb CountByProductName\v IDH_TJvHidDeviceController_CountByProductName>Main}\line
\{bmct empty.bmp\}\tab{\uldb CountByVendorName\v IDH_TJvHidDeviceController_CountByVendorName>Main}\line
\{bmct empty.bmp\}\tab{\uldb CountByCallback\v IDH_TJvHidDeviceController_CountByCallback>Main}\line
\{bmct empty.bmp\}\tab{\uldb DeviceChange\v IDH_TJvHidDeviceController_DeviceChange>Main}\line
\{bmct empty.bmp\}\tab{\uldb Destroy\v IDH_TJvHidDeviceController_Destroy>Main}\line
\{bmct empty.bmp\}\tab{\uldb Enumerate\v IDH_TJvHidDeviceController_Enumerate>Main}\line
\{bmct empty.bmp\}\tab{\uldb HidVersion\v IDH_TJvHidDeviceController_HidVersion>Main}
}\par\page

#{\footnote # pme_ce_TJvHidDeviceController}
${\footnote $ Events for TJvHidDeviceController}
+{\footnote + Auto}
\sa50\sb50{\keepn{\f1\fs20\cf2\b{\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController>Main} Events\b0}\line
{\fs20{\ul Legend\v IDH_Legend}}\par\pard}
{\f1\tx300\b In TJvHidDeviceController\b0\line
\{bmct Published.bmp\}\tab{\uldb OnArrival\v IDH_TJvHidDeviceController_OnArrival>Main}\line
\{bmct Published.bmp\}\tab{\uldb OnDeviceChange\v IDH_TJvHidDeviceController_OnDeviceChange>Main}\line
\{bmct Published.bmp\}\tab{\uldb OnDeviceData\v IDH_TJvHidDeviceController_OnDeviceData>Main}\line
\{bmct Published.bmp\}\tab{\uldb OnDeviceDataError\v IDH_TJvHidDeviceController_OnDeviceDataError>Main}\line
\{bmct Published.bmp\}\tab{\uldb OnDeviceUnplug\v IDH_TJvHidDeviceController_OnDeviceUnplug>Main}\line
\{bmct Published.bmp\}\tab{\uldb OnEnumerate\v IDH_TJvHidDeviceController_OnEnumerate>Main}\line
\{bmct Published.bmp\}\tab{\uldb OnRemoval\v IDH_TJvHidDeviceController_OnRemoval>Main}
}\par\page

#{\footnote # pme_ce_Other}
${\footnote $ HID functions not in scope}
+{\footnote + Auto}
\sa50\sb50{\keepn{\f1\fs20\cf2\b{\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController>Main} Other\b0}\line
{\fs20{\ul Legend\v IDH_Legend}}\par\pard}
{\f1\tx300\b Functions not in component\b0\line
{\uldb HidD_Hello\v Other_HidD_Hello>Main}\line
{\uldb HidP_UsageListDifference\v Other_HidP_UsageListDifference>Main}\line
{\uldb HidP_TranslateUsagesToI8042ScanCodes\v Other_HidP_TranslateUsagesToI8042ScanCodes>Main}
}\par\page

#{\footnote # Other_HidD_Hello}
${\footnote $ HidD_Hello}
K{\footnote K HidD_Hello}
A{\footnote A HidD_Hello}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b HidD_Hello\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} HidD_Hello(Buffer: PChar; BufferLength: ULONG): ULONG; {\b stdcall};}\par
The undocumented easter egg function of HID.DLL. 
The function fills Buffer with\line
{\f0   'Hello\\nI hate Jello\\n'}\line
and returns the 
number of bytes filled in (StrLen(Buffer)+1 = 20).\par
The function does not check its parameters completely. 
Handing in {\f0\b nil} as buffer gives access violation. 
It always returns 20 even if buffer length is less than 20, 
but does not produce buffer overflow.
\par\page

#{\footnote # Other_HidP_UsageListDifference}
${\footnote $ HidP_UsageListDifference}
K{\footnote K HidP_UsageListDifference}
A{\footnote A HidP_UsageListDifference}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b HidP_UsageListDifference\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} HidP_UsageListDifference(PreviousUsageList: PUsage;\line
  CurrentUsageList: PUsage; BreakUsageList: PUsage;\line
  MakeUsageList: PUsage; UsageListLength: ULONG): NTSTATUS; {\b stdcall};}\par
Fills BreakUsageList with all usages which are in PreviousUsageList but not in CurrentUsageList. 
MakeUsageList is filled with all usages in CurrentUsageList but not in PreviousUsageList. 
UsageListLength is the length for all lists and should be the length of the longer of PreviousUsageList and CurrentUsageList. 
A Usage value of zero marks the end of a list.
\par\page

#{\footnote # Other_HidP_TranslateUsagesToI8042ScanCodes}
${\footnote $ HidP_TranslateUsagesToI8042ScanCodes}
K{\footnote K HidP_TranslateUsagesToI8042ScanCodes}
A{\footnote A HidP_TranslateUsagesToI8042ScanCodes}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b HidP_TranslateUsagesToI8042ScanCodes\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} HidP_TranslateUsagesToI8042ScanCodes(\line
  ChangedUsageList: PUsage;\line
  UsageListLength: ULONG;\line
  KeyAction: THIDPKeyboardDirection;\line
  var ModifierState: THIDPKeyboardModifierState;\line
  InsertCodesProcedure: THIDPInsertScanCodes;\line
  InsertCodesContext: Pointer): NTSTATUS; {\b stdcall};}\par
There is no documentation for this function. It seems to be the utility function 
for the Windows keyboard class driver to change USB key codes to standard PS/2 
scancodes.
\par\page

#{\footnote # pme_ce_Utilities}
${\footnote $ Utility functions for TJvHidDevice}
+{\footnote + Auto}
\sa50\sb50{\keepn{\f1\fs20\cf2\b{\uldb TJvHidDevice\v IDH_Class_TJvHidDevice>Main} Utilities\b0}\line
{\fs20{\ul Legend\v IDH_Legend}}\par\pard}
{\f1\tx300\b Utility functions for TJvHidDevice\b0\line
{\uldb HidCheck\v Utilities_HidCheck>Main}\line
{\uldb HidError\v Utilities_HidError>Main}\line
{\uldb HidErrorString\v Utilities_HidErrorString>Main}\line
}\par\page

#{\footnote # Utilities_HidCheck}
${\footnote $ HidCheck}
K{\footnote K HidCheck}
A{\footnote A HidCheck}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b HidCheck\b0}\line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} HidCheck({\b const} RetVal: NTSTATUS): NTSTATUS; {\b overload};\line
{\b function} HidCheck({\b const} RetVal: LongBool): LongBool; {\b overload};}\par
This function checks the return value of a HID function or method of 
a TJvHidDevice object. If the method returns an error HidCheck throws an exception 
by calling {\uldb HidError\v Utilities_HidError}. The return value is always RetVal.
\par\page

#{\footnote # Utilities_HidError}
${\footnote $ HidError}
K{\footnote K HidError}
A{\footnote A HidError}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b HidError\b0}\line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} HidError({\b const} RetVal: NTSTATUS): NTSTATUS;}\par
HidError throws an exception with an appropriate error text 
if RetVal is in the range of the HID error values. The return value is always RetVal.
\par\page

#{\footnote # Utilities_HidErrorString}
${\footnote $ HidErrorString}
K{\footnote K HidErrorString}
A{\footnote A HidErrorString}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b HidErrorString\b0}\line
{\fs20    {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} HidErrorString({\b const} RetVal: NTSTATUS): {\b string};}\par
HidErrorString returns the appropriate error text 
if RetVal is in the range of the HID error values. Otherwise the result is empty.
\par\page

#{\footnote # IDH_TJvHidDeviceController_DevThreadSleepTime}
${\footnote $ TJvHidDeviceController.DevThreadSleepTime}
K{\footnote K TJvHidDeviceController,DevThreadSleepTime;DevThreadSleepTime,TJvHidDeviceController;DevThreadSleepTime}
A{\footnote A TJvHidDeviceController_DevThreadSleepTime;DevThreadSleepTime_Property;DevThreadSleepTime}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDeviceController.DevThreadSleepTime\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} DevThreadSleepTime: Integer;}\par
This property is not for the TJvHidDeviceController but is set to the {\uldb ThreadSleepTime\v IDH_TJvHidDevice_ThreadSleepTime>Main} 
property of each TJvHidDevice on creation. This allows to set the ThreadSleepTime value for all TJvHidDevice objects at design time. 
Changing the ThreadSleepTime value for an individual device is only possible at runtime. Only then the TJvHidDevice object exists.\line
Setting DevThreadSleepTime at runtime to a new value changes all TJvHidDevice.ThreadSleepTime properties which have the same old value. 
That is if you set a TJvHidDevice.ThreadSleepTime to an individual value then it will not be changed by DevThreadSleepTime assignment.
\par\page

#{\footnote # IDH_TJvHidDeviceController_HidGuid}
${\footnote $ TJvHidDeviceController.HidGuid}
K{\footnote K TJvHidDeviceController,HidGuid;HidGuid,TJvHidDeviceController;HidGuid}
A{\footnote A TJvHidDeviceController_HidGuid;HidGuid_Property;HidGuid}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDeviceController.HidGuid\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} HidGuid: TGUID;}\par
The GUID of the HID stack. It is of no importance for TJvHidDeviceController.\line
It is only present to provide all elements of the HID API if you want to enumerate the 
HID devices directly with SetupDiGetClassDevs() and SetupDiEnumDeviceInterfaces()  
from the Setup API conversion (SetupApi.pas, http://delphi-jedi.org/APILIBARY).
\par\page

#{\footnote # IDH_TJvHidDeviceController_NumCheckedInDevices}
${\footnote $ TJvHidDeviceController.NumCheckedInDevices}
K{\footnote K TJvHidDeviceController,NumCheckedInDevices;NumCheckedInDevices,TJvHidDeviceController;NumCheckedInDevices}
A{\footnote A TJvHidDeviceController_NumCheckedInDevices;NumCheckedInDevices_Property;NumCheckedInDevices}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDeviceController.NumCheckedInDevices\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} NumCheckedInDevices: Integer;}\par
The property tells the number of currently checked in HID devices. 
{\uldb NumCheckedInDevices\v IDH_TJvHidDeviceController_NumCheckedInDevices} + 
{\uldb NumCheckedOutDevices\v IDH_TJvHidDeviceController_NumCheckedOutDevices} tells the number of all controlled devices.
\par\page

#{\footnote # IDH_TJvHidDeviceController_NumCheckedOutDevices}
${\footnote $ TJvHidDeviceController.NumCheckedOutDevices}
K{\footnote K TJvHidDeviceController,NumCheckedOutDevices;NumCheckedOutDevices,TJvHidDeviceController;NumCheckedOutDevices}
A{\footnote A TJvHidDeviceController_NumCheckedOutDevices;NumCheckedOutDevices_Property;NumCheckedOutDevices}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDeviceController.NumCheckedOutDevices\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} NumCheckedOutDevices: Integer;}\par
The property tells the number of currently checked out HID devices. 
{\uldb NumCheckedInDevices\v IDH_TJvHidDeviceController_NumCheckedInDevices} + 
{\uldb NumCheckedOutDevices\v IDH_TJvHidDeviceController_NumCheckedOutDevices} tells the number of all controlled devices.
\par\page

#{\footnote # IDH_TJvHidDeviceController_NumUnpluggedDevices}
${\footnote $ TJvHidDeviceController.NumUnpluggedDevices}
K{\footnote K TJvHidDeviceController,NumUnpluggedDevices;NumUnpluggedDevices,TJvHidDeviceController;NumUnpluggedDevices}
A{\footnote A TJvHidDeviceController_NumUnpluggedDevices;NumUnpluggedDevices_Property;NumUnpluggedDevices}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDeviceController.NumUnpluggedDevices\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} NumUnpluggedDevices: Integer;}\par
The property tells the number of device objects where the device has been unplugged, but 
the device object has not been freed or checked back in yet.\line
{\uldb NumCheckedOutDevices\v IDH_TJvHidDeviceController_NumCheckedOutDevices} does not count such device objects 
despite the fact that they are formally in the state of being checked out.
\par\page

#{\footnote # IDH_TJvHidDeviceController_Version}
${\footnote $ TJvHidDeviceController.Version}
K{\footnote K TJvHidDeviceController,Version;Version,TJvHidDeviceController;Version}
A{\footnote A TJvHidDeviceController_Version;Version_Property;Version}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDeviceController.Version\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b property} Version: {\b string};}\par
Version shows the version string of the component. It is not stored in the .dfm file. 
Its main use is to have the version information at hand in the IDE.
\par\page

#{\footnote # IDH_TJvHidDeviceController_CheckIn}
${\footnote $ TJvHidDeviceController.CheckIn}
K{\footnote K TJvHidDeviceController,CheckIn;CheckIn,TJvHidDeviceController;CheckIn}
A{\footnote A TJvHidDeviceController_CheckIn;CheckIn_Method;CheckIn}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDeviceController.CheckIn\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b procedure} CheckIn({\b var} HidDev: {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice});}\par
Gives a checked out {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice} object back to the TJvHidDeviceController.\line
Hand the object back if you are finished using it. The file descriptors get closed 
on check in. 
CheckIn also sets HidDev to {\b nil} to prevent further use.\line
As an alternative call TJvHidDevice.Free. The TJvHidDeviceController gets informed and will create a new 
checked in TJvHidDevice object for the device if neccessary.\line
Destroying a TJvHidDeviceController with checked out TJvHidDevice objects results in pulling the virtual plug 
of all the TJvHidDevice objects. You will also receive an {\uldb OnUnplug\v IDH_TJvHidDevice_OnUnplug>Main} event 
for each device unplugged if the event is assigned. The TJvHidDevice objects remain but cease to work.
\par\page

#{\footnote # IDH_TJvHidDeviceController_CheckOut}
${\footnote $ TJvHidDeviceController.CheckOut}
K{\footnote K TJvHidDeviceController,CheckOut;CheckOut,TJvHidDeviceController;CheckOut}
A{\footnote A TJvHidDeviceController_CheckOut;CheckOut_Method;CheckOut}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDeviceController.CheckOut\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} CheckOut({\b var} HidDev: {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}): Boolean;}\par
Hands out the first TJvHidDevice object which is not checked out already.\line
The return value is True if there was a TJvHidDevice object to hand out. 
Otherwise the return value is False and HidDev is set to {\b nil}.
\par\page

#{\footnote # IDH_TJvHidDeviceController_CheckOutByID}
${\footnote $ TJvHidDeviceController.CheckOutByID}
K{\footnote K TJvHidDeviceController,CheckOutByID;CheckOutByID,TJvHidDeviceController;CheckOutByID}
A{\footnote A TJvHidDeviceController_CheckOutByID;CheckOutByID_Method;CheckOutByID}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDeviceController.CheckOutByID\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} CheckOutByID({\b var} HidDev: {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}; {\b const} Vid, Pid: Integer): Boolean;}\par
Hands out the first TJvHidDevice object which is not checked out already and where the device VendorID and ProductID match Vid and Pid. 
The value -1 for Pid matches all ProductIDs.\line
The return value is True if there was a TJvHidDevice object to hand out. 
Otherwise the return value is False and HidDev is set to {\b nil}.\par
\par\page

#{\footnote # IDH_TJvHidDeviceController_CheckOutByClass}
${\footnote $ TJvHidDeviceController.CheckOutByClass}
K{\footnote K TJvHidDeviceController,CheckOutByClass;CheckOutByClass,TJvHidDeviceController;CheckOutByClass;cHidMouseClass;cHidKeyboardClass;cHidNoClass}
A{\footnote A TJvHidDeviceController_CheckOutByClass;CheckOutByClass_Method;CheckOutByClass}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDeviceController.CheckOutByClass\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} CheckOutByClass({\b var} HidDev: {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}; {\b const} ClassName: {\b string}): Boolean;}\par
Hands out the first TJvHidDevice object which is not checked out already and where the device class matches the string of ClassName. 
The string is a user friendly class description and is defined in the registry under 
HKEY_LOCAL_MACHINE\\Enum\\HID\\...\\Class.\line
The return value is True if there was a TJvHidDevice object to hand out. 
Otherwise the return value is False and HidDev is set to {\b nil}.\par
These are three predefined string constants for ClassName:\line
{\f0   cHidMouseClass    = 'Mouse';}\line
{\f0   cHidKeyboardClass = 'Keyboard';}\line
{\f0   cHidNoClass       = 'HIDClass';}\line
For the other possible HID classes the information for the strings is missing.
\par\page

#{\footnote # IDH_TJvHidDeviceController_CheckOutByIndex}
${\footnote $ TJvHidDeviceController.CheckOutByIndex}
K{\footnote K TJvHidDeviceController,CheckOutByIndex;CheckOutByIndex,TJvHidDeviceController;CheckOutByIndex}
A{\footnote A TJvHidDeviceController_CheckOutByIndex;CheckOutByIndex_Method;CheckOutByIndex}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDeviceController.CheckOutByIndex\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} CheckOutByIndex({\b var} HidDev: {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}; {\b const} Idx: Integer): Boolean;}\par
Hands out the TJvHidDevice object with the index Idx if it is not checked out already. 
The index is zero based. The {\uldb OnEnumerate\v IDH_TJvHidDeviceController_OnEnumerate>Main} event provides the index of the enumerated device.\line
The return value is True if the index is within bounds and the TJvHidDevice object was not checked out already. 
Otherwise the return value is False and HidDev is set to {\b nil}.\par
\par\page

#{\footnote # IDH_TJvHidDeviceController_CheckOutByProductName}
${\footnote $ TJvHidDeviceController.CheckOutByProductName}
K{\footnote K TJvHidDeviceController,CheckOutByProductName;CheckOutByProductName,TJvHidDeviceController;CheckOutByProductName}
A{\footnote A TJvHidDeviceController_CheckOutByProductName;CheckOutByProductName_Method;CheckOutByProductName}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDeviceController.CheckOutByProductName\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} CheckOutByProductName({\b var} HidDev: {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}; ProductName: WideString): Boolean;}\par
Hands out the first TJvHidDevice object which is not checked out already and where the product name of the device matches ProductName. 
The product name comes directly from the firmware of the device. It may be an empty string. 
The match is made with Unicode strings.\line
The return value is True if there was a TJvHidDevice object to hand out. 
Otherwise the return value is False and HidDev is set to {\b nil}.\par
\par\page

#{\footnote # IDH_TJvHidDeviceController_CheckOutByVendorName}
${\footnote $ TJvHidDeviceController.CheckOutByVendorName}
K{\footnote K TJvHidDeviceController,CheckOutByVendorName;CheckOutByVendorName,TJvHidDeviceController;CheckOutByVendorName}
A{\footnote A TJvHidDeviceController_CheckOutByVendorName;CheckOutByVendorName_Method;CheckOutByVendorName}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDeviceController.CheckOutByVendorName\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} CheckOutByVendorName({\b var} HidDev: {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}; {\b const} VendorName: WideString): Boolean;}\par
Hands out the first TJvHidDevice object which is not checked out already and where the vendor name of the device matches VendorName. 
The vendor name comes directly from the firmware of the device. It may be an empty string.
The match is made with Unicode strings.\line
The return value is True if there was a TJvHidDevice object to hand out. 
Otherwise the return value is False and HidDev is set to {\b nil}.\par
\par\page

#{\footnote # IDH_TJvHidDeviceController_CheckOutByCallback}
${\footnote $ TJvHidDeviceController.CheckOutByCallback}
K{\footnote K TJvHidDeviceController,CheckOutByCallback;CheckOutByCallback,TJvHidDeviceController;CheckOutByCallback}
A{\footnote A TJvHidDeviceController_CheckOutByCallback;CheckOutByCallback_Method;CheckOutByCallback}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDeviceController.CheckOutByCallback\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} CheckOutByCallback({\b var} HidDev: {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}; Check: {\uldb TJvHidCheckCallback\v IDH_Type_TJvHidCheckCallback}): Boolean;}\par
Hands out the first TJvHidDevice object which is not checked out already and where the user supplied function Check returns True. 
Only checked in devices are presented to the Check function.\line
The return value is True if there was a TJvHidDevice object to hand out. 
Otherwise the return value is False and HidDev is set to {\b nil}.\par
\par\page

#{\footnote # IDH_Type_TJvHidCheckCallback}
${\footnote $ TJvHidCheckCallback}
K{\footnote K TJvHidCheckCallback}
A{\footnote A TJvHidCheckCallback_Type;TJvHidCheckCallback}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidCheckCallback\b0}   \line
\par\pard}
\b Declaration\b0\par
{\f0 TJvHidCheckCallback = {\b function}({\b const} HidDev: TJvHidDevice): Boolean\par}
User supplied callback function to check out a HID device.
\par\page

#{\footnote # IDH_TJvHidDeviceController_CountByID}
${\footnote $ TJvHidDeviceController.CountByID}
K{\footnote K TJvHidDeviceController,CountByID;CountByID,TJvHidDeviceController;CountByID}
A{\footnote A TJvHidDeviceController_CountByID;CountByID_Method;CountByID}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDeviceController.CountByID\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} CountByID({\b const} Vid, Pid: Integer): Integer;}\par
Returns the number of plugged devices where the device VendorID and ProductID match Vid and Pid. 
The value -1 for Pid matches all ProductIDs.
\par\page

#{\footnote # IDH_TJvHidDeviceController_CountByClass}
${\footnote $ TJvHidDeviceController.CountByClass}
K{\footnote K TJvHidDeviceController,CountByClass;CountByClass,TJvHidDeviceController;CountByClass;cHidMouseClass;cHidKeyboardClass;cHidNoClass}
A{\footnote A TJvHidDeviceController_CountByClass;CountByClass_Method;CountByClass}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDeviceController.CountByClass\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} CountByClass({\b const} ClassName: {\b string}): Integer;}\par
Returns the number of plugged devices where the device class matches the string of ClassName. 
The string is a user friendly class description and is defined in the registry under 
HKEY_LOCAL_MACHINE\\Enum\\HID\\...\\Class.\line
The are three predefined string constants for ClassName:\line
{\f0   cHidMouseClass    = 'Mouse';}\line
{\f0   cHidKeyboardClass = 'Keyboard';}\line
{\f0   cHidNoClass       = 'HIDClass';}\line
For the other possible HID classes the information for the strings is missing.
\par\page

#{\footnote # IDH_TJvHidDeviceController_CountByProductName}
${\footnote $ TJvHidDeviceController.CountByProductName}
K{\footnote K TJvHidDeviceController,CountByProductName;CountByProductName,TJvHidDeviceController;CountByProductName}
A{\footnote A TJvHidDeviceController_CountByProductName;CountByProductName_Method;CountByProductName}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDeviceController.CountByProductName\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} CountByProductName({\b const} ProductName: WideString): Integer;}\par
Returns the number of plugged devices where the product name of the device matches ProductName. 
The match is made with Unicode strings. 
The product name comes directly from the firmware of the device. It may be an empty string.
\par\page

#{\footnote # IDH_TJvHidDeviceController_CountByVendorName}
${\footnote $ TJvHidDeviceController.CountByVendorName}
K{\footnote K TJvHidDeviceController,CountByVendorName;CountByVendorName,TJvHidDeviceController;CountByVendorName}
A{\footnote A TJvHidDeviceController_CountByVendorName;CountByVendorName_Method;CountByVendorName}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDeviceController.CountByVendorName\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} CountByVendorName({\b const} VendorName: WideString): Integer;}\par
Returns the number of plugged devices where the vendor name of the device matches VendorName. 
The match is made with Unicode strings. 
The vendor name comes directly from the firmware of the device. It may be an empty string.
\par\page

#{\footnote # IDH_TJvHidDeviceController_CountByCallback}
${\footnote $ TJvHidDeviceController.CountByCallback}
K{\footnote K TJvHidDeviceController,CountByCallback;CountByCallback,TJvHidDeviceController;CountByCallback}
A{\footnote A TJvHidDeviceController_CountByCallback;CountByCallback_Method;CountByCallback}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDeviceController.CountByCallback\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} CountByCallback(Check: {\uldb TJvHidCheckCallback\v IDH_Type_TJvHidCheckCallback}): Integer;}\par
Returns the number of plugged devices where the user supplied Check function returns True.
\par\page

#{\footnote # IDH_TJvHidDeviceController_Create}
${\footnote $ TJvHidDeviceController.Create}
K{\footnote K TJvHidDeviceController,Create;Create,TJvHidDeviceController;Create}
A{\footnote A TJvHidDeviceController_Create;Create_Method;Create}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDeviceController.Create\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b constructor} Create(AOwner: TComponent); {\b override};}\par
You may override the constructor if you like, but do not forget to call "{\f0 {\b inherited} Create(AOwner);}" 
as first statement of the overridden constructor or the whole component will never start to work.
\par\page

#{\footnote # IDH_TJvHidDeviceController_DeviceChange}
${\footnote $ TJvHidDeviceController.DeviceChange}
K{\footnote K TJvHidDeviceController,DeviceChange;DeviceChange,TJvHidDeviceController;DeviceChange}
A{\footnote A TJvHidDeviceController_DeviceChange;DeviceChange_Method;DeviceChange}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDeviceController.DeviceChange\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b procedure} DeviceChange;}\par
The procedure implements the {\uldb OnDeviceChange\v IDH_TJvHidDeviceController_OnDeviceChange>Main} event. It has been made {\b published} to make 
it callable at design time. The event is not fired by this procedure because it is only 
fired when a change in plugged HID devices happened. Such events are fired automatically.
\par\page

#{\footnote # IDH_TJvHidDeviceController_Destroy}
${\footnote $ TJvHidDeviceController.Destroy}
K{\footnote K TJvHidDeviceController,Destroy;Destroy,TJvHidDeviceController;Destroy}
A{\footnote A TJvHidDeviceController_Destroy;Destroy_Method;Destroy}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDeviceController.Destroy\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b destructor} Destroy; {\b override};}\par
You may override the destructor if you like, but do not forget to call "{\f0 {\b inherited} Destroy;}" 
as last statement of the overridden destructor or the component cannot clean up correctly.
\par\page

#{\footnote # IDH_TJvHidDeviceController_Enumerate}
${\footnote $ TJvHidDeviceController.Enumerate}
K{\footnote K TJvHidDeviceController,Enumerate;Enumerate,TJvHidDeviceController;Enumerate}
A{\footnote A TJvHidDeviceController_Enumerate;Enumerate_Method;Enumerate}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDeviceController.Enumerate\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b function} Enumerate: Integer;}\par
The Enumerate method fires an {\uldb OnEnumerate\v IDH_TJvHidDeviceController_OnEnumerate>Main} 
event for each device in the list of the TJvHidDeviceController. This is the only way to get an OnEnumerate event. 
All devices in the list are enumerated. Checked in or not, plugged in or not. 
If the OnEnumerate event returns False the enumeration process stops prematurely.
\par\page

#{\footnote # IDH_TJvHidDeviceController_HidVersion}
${\footnote $ TJvHidDeviceController.HidVersion}
K{\footnote K TJvHidDeviceController,HidVersion;HidVersion,TJvHidDeviceController;HidVersion}
A{\footnote A TJvHidDeviceController_HidVersion;HidVersion_Method;HidVersion}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDeviceController.HidVersion\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 {\b class function} HidVersion: {\b string};}\par
The function returns the version string from HID.DLL. It has been made a class function to 
allow to call it without having a TJvHidDeviceController object created.\line
A sample call:\par
{\f0   ShowMessage(TJvHidDeviceController.HidVersion);}
\par\page

#{\footnote # IDH_TJvHidDeviceController_OnArrival}
${\footnote $ TJvHidDeviceController.OnArrival}
K{\footnote K TJvHidDeviceController,OnArrival;OnArrival,TJvHidDeviceController;OnArrival}
A{\footnote A TJvHidDeviceController_OnArrival;OnArrival_Event;OnArrival}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDeviceController.OnArrival\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 TJvHidPlugEvent = {\b procedure}(HidDev: {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}) {\b of} {\b object};}\par
The TJvHidDeviceController fires this event each time a HID device is plugged. 
It is followed by an {\uldb OnDeviceChange\v IDH_TJvHidDeviceController_OnDeviceChange>Main} event. 
The device is accessible during the event.
\par\page

#{\footnote # IDH_TJvHidDeviceController_OnDeviceChange}
${\footnote $ TJvHidDeviceController.OnDeviceChange}
K{\footnote K TJvHidDeviceController,OnDeviceChange;OnDeviceChange,TJvHidDeviceController;OnDeviceChange}
A{\footnote A TJvHidDeviceController_OnDeviceChange;OnDeviceChange_Event;OnDeviceChange}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDeviceController.OnDeviceChange\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 TNotifyEvent = {\b procedure}(Sender: TObject) {\b of object};}\par
The TJvHidDeviceController fires this event each time a HID device is plugged or unplugged. 
The event is also fired at runtime when the OnDeviceChange is assigned the first time, 
which happens automatically at program start if the event has been set at design time. 
Fireing the event on assignment simulates the plug of all devices already plugged.\line
This is the place to check out a freshly arrived device. Sender is of course the TJvHidDeviceController component itself.
\par\page

#{\footnote # IDH_TJvHidDeviceController_OnDeviceData}
${\footnote $ TJvHidDeviceController.OnDeviceData}
K{\footnote K TJvHidDeviceController,OnDeviceData;OnDeviceData,TJvHidDeviceController;OnDeviceData}
A{\footnote A TJvHidDeviceController_OnDeviceData;OnDeviceData_Event;OnDeviceData}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDeviceController.OnDeviceData\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 TJvHidDataEvent = {\b procedure}({\b const} HidDev: {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}; ReportID: Byte; 
{\b const} Data: Pointer; Size: Word) {\b of} {\b object};}\par
This event is not for the TJvHidDeviceController but is set to the {\uldb OnData\v IDH_TJvHidDevice_OnData>Main} 
event of each TJvHidDevice on creation. This allows to set the OnData event for all TJvHidDevice objects at design time. 
Changing the OnData event for an individual device is only possible at runtime. Only then the TJvHidDevice object exists.\line
Setting OnDeviceData at runtime to a new value changes all TJvHidDevice.OnData events which have the same old value. 
That is if you set a TJvHidDevice.OnData to an individual event then it will not be changed by OnDeviceData assignment.
\par\page

#{\footnote # IDH_TJvHidDeviceController_OnDeviceDataError}
${\footnote $ TJvHidDeviceController.OnDeviceDataError}
K{\footnote K TJvHidDeviceController,OnDeviceDataError;OnDeviceDataError,TJvHidDeviceController;OnDeviceDataError}
A{\footnote A TJvHidDeviceController_OnDeviceDataError;OnDeviceDataError_Event;OnDeviceDataError}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDeviceController.OnDeviceDataError\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 TJvHidDataErrorEvent = {\b procedure}({\b const} HidDev: {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}; 
Error: DWORD) {\b of} {\b object};}\par
This event is not for the TJvHidDeviceController but is set to the {\uldb OnDataError\v IDH_TJvHidDevice_OnDataError>Main} 
event of each TJvHidDevice on creation. This allows to set the OnDataError event for all TJvHidDevice objects at design time. 
Changing the OnDataError event for an individual device is only possible at runtime. Only then the TJvHidDevice object exists.\line
Setting OnDeviceDataError at runtime to a new value changes all TJvHidDevice.OnDataError events which have the same old value. 
That is if you set a TJvHidDevice.OnDataError to an individual event then it will not be changed by OnDeviceDataError assignment.
\par\page

#{\footnote # IDH_TJvHidDeviceController_OnDeviceUnplug}
${\footnote $ TJvHidDeviceController.OnDeviceUnplug}
K{\footnote K TJvHidDeviceController,OnDeviceUnplug;OnDeviceUnplug,TJvHidDeviceController;OnDeviceUnplug}
A{\footnote A TJvHidDeviceController_OnDeviceUnplug;OnDeviceUnplug_Event;OnDeviceUnplug}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDeviceController.OnDeviceUnplug\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 TJvHidUnplugEvent = {\b procedure}({\b const} HidDev: {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}) {\b of} {\b object};}\par
This event is not for the TJvHidDeviceController but is set to the {\uldb OnUnplug\v IDH_TJvHidDevice_OnUnplug>Main} 
event of each TJvHidDevice on creation. This allows to set the OnUnplug event for all TJvHidDevice objects at design time. 
Changing the OnOnplug event for an individual device is only possible at runtime. Only then the TJvHidDevice object exists.\line
Setting OnDeviceUnplug at runtime to a new value changes all TJvHidDevice.OnUnplug events which have the same old value. 
That is if you set a TJvHidDevice.OnUnplug to an individual event then it will not be changed by OnDeviceUnplug assignment.
\par\page

#{\footnote # IDH_TJvHidDeviceController_OnEnumerate}
${\footnote $ TJvHidDeviceController.OnEnumerate}
K{\footnote K TJvHidDeviceController,OnEnumerate;OnEnumerate,TJvHidDeviceController;OnEnumerate}
A{\footnote A TJvHidDeviceController_OnEnumerate;OnEnumerate_Event;OnEnumerate}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDeviceController.OnEnumerate\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 TJvHidEnumerateEvent = {\b function}({\b const} HidDev: {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}; {\b const} Idx: Integer): Boolean {\b of object};}\par
The OnEnumerate event is fired by the {\uldb Enumerate\v IDH_TJvHidDeviceController_Enumerate>Main} method for each device in the list of the TJvHidDeviceController. 
Returning False for this event stops the enumeration process prematurely.\line
All devices in the list are enumerated. Checked in or not, plugged in or not. 
It is explicitely allowed to check out or check in a device inside the event. 
This allows to implement complicated matches which are not covered by the Count methods. 
The index Idx is provided to check out a device with {\uldb CheckOutByIndex\v IDH_TJvHidDeviceController_CheckOutByIndex>Main}.\par
The HidDev handed to the event is fully functional even if checked in. 
The file handles of a checked in device get closed after the event and 
the device object ceases to work. So better do not try to use such an 
object outside the OnEnumerate event.
\par\page

#{\footnote # IDH_TJvHidDeviceController_OnRemoval}
${\footnote $ TJvHidDeviceController.OnRemoval}
K{\footnote K TJvHidDeviceController,OnRemoval;OnRemoval,TJvHidDeviceController;OnRemoval}
A{\footnote A TJvHidDeviceController_OnRemoval;OnRemoval_Event;OnRemoval}
>{\footnote > main}
+{\footnote + Auto}
\sa50\sb50{\keepn{\uldb \{bml usb.bmp\}\v Robert_Marquardt}{\fs24\cf2\b TJvHidDeviceController.OnRemoval\b0}\line
{\fs20    {\uldb TJvHidDeviceController\v IDH_Class_TJvHidDeviceController}   }\par\pard}
\b Declaration\b0\par
{\f0 TJvHidUnplugEvent = {\b procedure}(HidDev: {\uldb TJvHidDevice\v IDH_Class_TJvHidDevice}) {\b of} {\b object};}\par
The TJvHidDeviceController fires this event each time a HID device is unplugged. 
It is followed by an {\uldb OnDeviceChange\v IDH_TJvHidDeviceController_OnDeviceChange>Main} event. 
The same event happens as {\uldb OnUnplug\v IDH_TJvHidDevice_OnUnplug>Main}, but for the device instead of the controller.
\par\page

#{\footnote # IDH_Anym_3FAMT_1}
\sa50\sb50
{\f1\fs20\b Hierarchy\b0\par
TObject\line
      |\line
{\cf2 TJvHidDevice}\line
\line
\b Subclasses\b0\line
 None}\par\page

#{\footnote # IDH_Anym_3FAMT_2}
\sa50\sb50{\f1\fs20\b Hierarchy\b0\par
TComponent\line
      |\line
{\cf2 TJvHidDeviceController}\line
\line
\b Subclasses\b0\line
 None}\par\page

#{\footnote # IDH_Legend}
\sa50\sb50
{\f1\fs20\b Scope\b0\line
\{bmct Published.bmp\}\tab Published\par
\b Accessibility\b0\line
\{bmct readonly.bmp\}\tab Read-only
}\par\page
}
